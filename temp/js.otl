[javascript]
	语法基础
		[typeof]
			typeof NaN // "number"
			typeof null // "object"
			typeof undefined // "undefined"
			typeof true // "boolean"
			typeof new String('123') // "object"
		[===][==] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness>
			如果 a === b，则a==b
			NaN != NaN
			+true === 1
			true == 1
			true == "1"
			true != "true"
			-0 === +0
			null == undefined
			null !== undefined
			null === null
			undefined === undefined
			Infinity === Infinity
			要从设计者的用意来理解 == 的比较规则
				[ToNumber(A)] 即+A运算，转为数字. 因为boolean更接近number类型，所以遇到boolean的比较，会转成数字来比
				[ToPrimitive(A)] 对于object的类型，primitive会依次取toString，valueOf
		布尔类型
			falsy值: ''
			true值: '0'
		数值类型
			取小数点固定几位: toFixed(3) // 取小数点后3位，返回的是字符串
		[undefined]
			undefined === undefined
		单双引号互括用于规避引号转义
			这是很多语言的做法
		>>> 无符号右移 
		...操作符
			对象里展开：{ ...xxx } 如果xxx不是对象，直接忽略
				即：...undefined, ...null, ...123 都是合法的，但仅限于对象内，在其他场合的使用方法会不同
			数组中的应用
				const arr = [1, 2, 3, 4, 5]
				let [...a, b] = arr // 错误！
				let [a, ...b] = arr // 正确
				可以直接把字符串转为数组
					当然split方法也可以
			函数参数中的奇招: function group(o, [...by], {...opt}){...}
				这样很明了参数的意图，并且传入的参数非法时，也能至少保证by是一个空数组, opt是一个空对象，而不会报错
			坑：
				[...undefined]是非法的，{...undefined}却又是合法，这已经被坑了好多次了
		交换变量 [a, b] = [b, a] // es6以上
		连等陷阱 <url:./filets/js/syntax/equal.js>
		(,)陷阱 <url:./filets/js/syntax/parentheses.js>
		[toString()]
			js里通常不提接口，但很多地方使用了对象的toString()方法来生成用于显示的字符串信息，这里属于js里"接口"理念的一个轻淡地体现
		[valueOf()]
		声明、赋值、运算符
			声明多个变量
				let a, b = 1 // a为undefined, b为1
			连等赋值
				let a = b.c = {}
			解构赋值（...）
				支持特殊字符串构成的key，例: const {'&:first-child':xx, ...rest} = a
				支持key里为变量：const {[aaa]:a, [bbb]:b} = x
			解构组合
				{...1, ...null, ...undefined, ...true} -> {}
			幂运算 2 ** 3 // = 8
	[other of global]其他内建对象
		[binary] 二进制
			另起炉灶
				无视Node的Buffer标准，重新定义几个新概念
			[ArrayBuffer]
				底层buffer，不直接操作
					作为TypedArray和DataView的载体
			[TypedArray] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray>
				记代表: Int8Array, Uint8Array, Float64Array
				只支持big endian
				享受Array的其他操作，这也是另起炉灶的原因之一
			[DataView] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView>
				类似C里的struct的操作
				支持指定endian
				.setInt16(12, 42, [true])
				.getInt16(3, [true])
			[Blob] 与文件联接
				new Blob([字符串, buffer, 或者blob, ...], {type: "text/plain;charset=utf-8"})
				最简单的用法：new Blob(['aa'])
			[File] Blob的扩展
				还是Blob，多了一些文件属性
				通常由控件取得
					比如file input，文件拖入
			[FileReader]
				new FileReader()
				提供读File方法, 通过reader.result来取值
					readAsDataURL(blob)
					readAsText(blob)
					readAsArrayBuffer(blob)
					...
				提供事件（遵循dom模型）
					load
					progress
					...
		[timers]
			[setTimeout]
				clearTimeout可以真正撤消（不同于asio会触发回调）
			[setInterval]
				timer = 窗口.setInterval(fn, time); clearInterval(timer)
		Date
			UTC: 世界统一时间。GMT: 格林威治时间. 可以认为是UTC的一种表达方式. 在date对象里，toUTCString === toGMTString [deprecated]
			date对象, 由new Date(...)生成, 直接调Date()等价于(new Date()).toString()
			new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])
			一系列的get*, set*方法，查文档
			直接生成毫秒值：Date.now
			Date.parse, Date.UTC
			高级功能：见moment库
		[URL] <url:https://developer.mozilla.org/en-US/docs/Web/API/URL>
			url的类
				和location相似
			浏览器端的两个方法
				根据文件快速创建一个临时url
					URL.createObjectURL(blob)
				回收临时url
					URL.revokeObjectURL(url)
			资料
				base64形式: 'data:image/png;base64,xxxxxxx' // 似乎逗号后没有空格
	parseInt, parseFloat: 在新的标准中，它们将被收编入Number类方法里。Number.parseInt === global.parseInt
	事件循环: 任务队列、执行栈
		据说有多个任务队列？不深究了. 总之Promise的then是异步，但前于setTimeout和setImmediate
		而setImmediate和setTimeout在浏览器和node上行为不同
	[Object] Object对象的酷魔法
		[Object.defineProperty]
			Object.defineProperty(obj, 'aa', ...)
			configurable
				一次性门，一旦关上则不能再被打开
			enumerable
			value
			writable
			get
			set
		[Object.keys]
			不取原型链, enumerable only
			对应_.keys()
		[Object.is]
			Object.is(NaN, NaN) => true
			Object.is(+0, 0) => true
			Object.is(+0, -0) => false
			Object.is(0, -0) => false
			其余时候同 ===
		[for in]
			会取原型链，enumerable only
		[Object.getOwnPropertyNames] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames>
		[restriction] 限制
			[Object.isExtensible] [Object.preventExtensions]
			[Object.isSealed] [Object.seal]
			[Object.isFrozen] [Object.freeze]
		[prototype]
			[obj.hasOwnProperty]
			[obj.propertyIsEnumerable]
	Symbol <url:https://blog.csdn.net/qq_33408245/article/details/82953143>
		解决标志变量、属性名全局唯一的问题
		Symbol()和 Symbol.for/Symbol.keyFor 并不共享
		需要通过Object.getOwnPropertySymbols才能枚举symbol属性. 或者通过反射Reflect.ownKeys
		Symbol.hasInstance
		Symbol.isConcatSpreadable
		Symbol.iterator
		Symbol.match: 只针对regxp是否能被startsWidth/endsWith
		Symbol.prototype
		Symbol.replace
		Symbol.search
		Symbol.species: 似乎只针对array.map的情况
		Symbol.split
		Symbol.toPrimitive: 便于快速转换类型, 比如 +x（转为number）
		Symbol.toStringTag
		Symbol.unscopables
			object1[Symbol.unscopables] = { property1: true };
			with (object1) { console.log(property1); } // 会报错
		Symbol.for()
		Symbol.keyFor()
		Symbol.prototype.toSource()
		Symbol.prototype.toString()
		Symbol.prototype.valueOf()
		Symbol.prototype[@@toPrimitive]
	[String]
		unicode问题
			在通常情况下，字母和中文字都作为一个字符（char）对待，对Unicode码点大于某个值的字符，js需要用两个长度来表示
			传统的方法（不能解决该问题）
				String.fromCharCode(num1[, num2...])
				str.charAt()，跟[]很像，但在一些边缘情况的行为略不同
				str.charCodeAt()
			新的方法
				String.fromCodePoint(num1[, num2...])
				str.codePointAt()
		template literal
			tagged template literal
				fn`some string here` 等价于 fn([ 'some string here' ])
				fn`this is a ${a} day ${b}` 等价于 fn([ 'this is a ', ' day ', '' ], a, b)
				如果不是tagged，`this is a ${a} day`将直接把a变量转成string
		str.length
		str.concat(string2[, string3, ..., stringN])
			和数组concat的用法类似，但建议直接用+运算符代替
		查找、替换
			正则语法糖: 参数不支持正则表达式，因此如果都传了正则，还需要这些语法糖干什么
				str.endsWith(searchString[, length]) 
				str.startsWith(searchString[, position])
				str.includes(searchString[, position])
			查找
				str.indexOf(s[, from])：from指定从哪里往后找
				str.lastIndexOf(s[, from])：from是指定从哪里往前找
					这里的from的负值行为不一样，如果为负，则相当于为0
				str.includes
			正则
				str.match(regexp)
					参数为正则表达式（如果传入的不是正则，将隐式转换）
					如果正则没有g，返回结果中str.match(regx)等价于regx.exec(str)
					如果有g，则返回一个所有匹配的数组
						一个纯数组，没有其他额外信息比如index
				str.search(regexp) 正则版的indexOf. 但没有第二个参数
				str.replace(regexp|substr, newSubstr|function)
					巧用replace可以用于从字符串中截取某个特定位置的子串 reg.replace(/<%\s*\.(.+?)\s*%>/, '$1')
					支持正则表达式，并支持选项，如/haha/g（当然也可以用字符串）
						很多高级用法，参见手册
					坑：如果不通过正则表达式指定/g，则默认只替换第一个找到的结果
					例：text.replace(/javascript/gi, "JavaScript")
					name = "Doe, John";
					name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1"); // John Doe
					如果要取整个串，好像是$&
					支持传入一个函数：
						text = text.replace(/<img src="res\/img\/biaoqing\/(.*?)\.bmp">/g, function (t)
						{
								t = t.slice(t.search(/\d+\.bmp/));
								t = t.slice(0, t.search(/\.bmp/));
								// 返回的字符串则表示要替换的新串
								return biaoqing_code[t];
						});
					如replace(/^[^\d.]*/, '')，代表什么含义？
		裁剪
			str.slice(begin[, end]) // to
				slice(0); // 相当于创建了字符串的副本
				slice(-2); // 从倒数第2个开始
				slice(1,3); // halfopen，即选1、2个，不包括第3个
				slice(0, -2) // 支持负数：去掉最后两个
			str.substr(start[, length]) // by
			str.substring(indexStart[, indexEnd]) // 很像slice. 一个重要的区别是 start和end支持交换
			str.trim()
			str.trimEnd(); str.trimRight();
			str.trimStart(); str.trimLeft();
			str.split([separator[, limit]])
				可以用正则
				'1232'.split() // ['1232']
				'1234'.split('') // ['1','2','3','4']
				'1234'.split('4') // ['123','']
				'22'.split('2') // ['', '', '']
		大小写
			str.toLowerCase()
			str.toUpperCase()
		画表格
			str.padEnd(targetLength [, padString])
			str.padStart(targetLength [, padString])
		str.repeat(count)
		String.raw`Hi\n${2+3}!` => Hi\n5，注\n就真的是'\n' + 'n'，而不是换行
		不常用
			str.localeCompare() 不常用，略
			str.normalize()
			str.toLocaleLowerCase()
			str.toLocaleUpperCase()
	Number
		==类==
		parseInt, parseFloat陷阱: 传入的参数是字符串. 
		==实例==
	[Array] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array>
		*表示改变原数组
		arr.length
		构造
			Array(3): 构造有三个元素的数组
			Array.from()
				Array.from(arrayLike[, mapFn[, thisArg]])
				Array.from(iterable)
			Array.of()
				跟new Array一个重要区别是：Array.of(7) => [7] 
		Array.isArray() 官方的判断是否为数组的方法，lodash也是调用它
		arr.concat(value1[, value2[, ...[, valueN]]])
		*arr.copyWithin(target[, start[, end]]): 类似c++里的move
			[1, 2, 3, 4, 5].copyWithin(-2, -3, -1); // [1, 2, 3, 3, 4]
		迭代
			arr.entries() 返回迭代器
				['a', 'b', 'c'] 迭代的内容是[0, 'a'], [1, 'b'], [2, 'c']
			arr.keys() 返回keys的迭代器（注：不是keys数组，似乎有点鸡肋）
		对标lodash: 但lodash的兼容性及容错性更强
			注：lodash不提供this参数）
			arr.some, arr.every, arr.filter
				arr.some(callback[, thisArg])
			arr.forEach（注：lodash有each和forEach，两者是alias关系）
			arr.map
			arr.reduce((a, c)=>new_a, init_value])：反向为reduceRight
				初始值可以缺省
			arr.reverse()
			arr.sort 和 _.sortBy 有所区别
		*splice(start[, deleteCount[, item1[, item2[, ...]]]]): 剪辑（字符串没有该方法）
			会改变原数组
			返回删除的子数组
			deleteCount缺省的话，会把后面的全删掉
		同字符串
			arr.includes
			arr.indexOf
			arr.lastIndexOf: 与数组不同！其from支持负，而数组如果from为负则相当于0
				[1,2,3,2].lastIndexOf(2,-2) // 1
				'1232'.lastIndexOf('2', -2) // -1
			arr.slice
		查找
			[arr.find]
				返回元素值
					arr.find(func[, thisArg])
			arr.findIndex(func[, thisArg]) 同find，但返回找到的元素index
		*栈和队列
			arr.push(element1[, ...[, elementN]])，返回push的数目
			arr.pop() 弹出最后一个元素，返回弹出的元素
			arr.unshift(element1[, ...[, elementN]]) 反向push
			arr.shift() 反向pop，弹出第一个元素，返回弹出的元素
		arr.join(sep = ',')
		arr.fill(value[, start[, end]]) // 填值
		提案中
			arr.flat(depth = 1)
			arr.flatMap(...) // 先map，再flattern 1级. 用于那些map函数会提升层级的场景
				[1, 2, 3, 4].flatMap(x => [x * 2]) => [2, 4, 6, 8]
	Math
		Math.min(1,2,3,4) / Math.max类似
		Math.hypot 用来求距离很方便: Math.hypot(3, 4) => 5
		Math.random() 0~1之间的小数
	函数
		函数的名字可以通过其name属性取到，但尽量不要依赖它。因为js压缩混淆之后，函数名会丢失
		函数的length: 即函数定义时的参数个数
			应该是确定参数的个数吧？对于(a, b, ...c)这种形式还未深究
		箭头函数技巧
			(([x])=>{ /* 当为对象，数组的解构形态时，外层 ( ) 不能省 */ console.log(x) })(['haha'])
			类里的箭头函数方法，是可以被完美继承的
		arguments
			似乎es6要将其相关特性废除（caller, callee等）
		自己约定
			纯函数用箭头函数，不纯函数使用function
	[class]
		[class declaration]
			getter和setter
				例：set value(val){this.value = val}
			es规范不支持多继承
				虽然可以人为实现，但值得思考是否必要
			杂
				私有属性、方法 #前缀: #a, #fun，好像现在babel还不支持
		[constructor function]
			[new] new的实质
				var obj  = {};  
				obj.__proto__ = Base.prototype;
				Base.call(obj);
			[inheritance]
				with __proto__
					Dog.prototype.__proto__ = Animal.prototype
				without __proto__
					方法就多种多样了
	/../ [RegExp] 正则表达式 <url:#r=regexp>
		正则表达式语法 <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions>
			\
			^, $
			*
			+
			?：{0,1}，又用来表示非贪婪模式，如a*?（可用于任意数量修饰符之后）
			.：除了\n，所以如果要匹配真正意义的任意字符，要用[^]，当然[\s\S]，[\d\D]等也可以
			(ｘ)：子匹配，子匹配是可以嵌套的. 放入寄存器的顺序是进栈的顺序，即'('的顺序（先根遍历）
			(?:ｘ)：匹配子模块但不放入$1-$9里
			ｘ(?=ｙ)：look ahead
			ｘ(?!ｙ)：negated look ahead
			现在也普遍支持look behind了:
				console.log(/(?<=Jack|Tom)Sprat/.test('TomSprat')) // true
				console.log(/(?<=Jack|Tom)Sprat/.test('TSprat')) // false
				(?<!a)b 匹配前面不跟着"a"的"b"
			ｘ|ｙ
			{n}
			{n,}
			{n,m}
			[ｘｙｚ]
			[^ｘｙｚ]
			[\b]
			\b word boundary. 词语的边界
			\B
			\cｘ
			\d
			\D
			\f
			\n
			\r
			\s
			\S
			\t
			\v
			\w
			\W
			\n
			\0
			\xｈｈ
			\uｈｈｈｈ
			\u{ｈｈ}
		构造函数
			字面量表示法略
			new RegExp()同RegExp()，可以接收一个字符串或者一个对象
				注：RegExp(/a/) 等价于RegExp('a') 但跟 RegExp('/a/')不等价!
				RegExp('ab+c', 'i') => /ab+c/
				RegExp('\\w+') => /\w+/
		flags（后缀）
			i 忽略大小写
			g 全局匹配（多个匹配）
			m 多行模式。缺省^和$匹配整个字符串的首和尾，启用了m之后，^和$则用来表示行首和行尾
			u unicode模式: 比如/a.b/u 中的「.」可以匹配一个大的unicode字符，但如果不加/u的话，仍会把大unicode字符当两个字符看待，导致不匹配
			y sticky
				sticky其实隐含了g的行为，区别是其严格按lastIndex所在的位置来检查是否匹配（普通情形是从lastIndex开始往后找到匹配就行）
		匹配检测方法
			[状态机]: regx是以状态机的机制来进行匹配的，尤其是对于g
			regx.test()：最常用的检测方法。注：对于g flag状态机，test可以多次调用来'查找下一个'，直到找不到时，会返回false。然后循环此过程。因此可用来进行查找计数
			regx.exec()：test的详尽版：除了返回true和false之外，还返回详尽的结果。状态机机制与test完全一样
				返回结果, 是一个扩展的数组{ 
					[匹配的串，...匹配的子串（取决有没有加括号）], 
					index: 匹配的位置, 
					input: 被检测的串}
					chrome里还有一个groups:undefined，暂时不知何用。mdn里没有介绍，firefox里没有该字段
				不匹配则返回null，然后循环
		寄存器: 只要发生成功的正则匹配，寄存器都会被刷新，如果匹配不成功，则寄存器的值不变
			RegExp.$1-$9：对应string.replace里的$1-$9. 取最后的9个. 它们未赋值状态下都是''
			RegExp.input（$_）：被测试的字符串
			RegExp.lastMatch（$&）：匹配的结果字符串（不是子匹配）
				其实命名里'last'修饰是多余的。这里所有寄存器隐含last的含义
			RegExp.lastParen（$+）：最后一个子匹配
				虽然它必然在$1-$9中，但你有时不知道是其中的哪一个
			RegExp.leftContext（$`）：匹配串前面的部分
			RegExp.rightContext（$'）：匹配串后面的部分
		regx.flags: 取flags，如'gi'，按字母顺序排列: /aa/mig.flgs => 'gim'
		regx.global, regx.ignorecase, regx.multiline, regx.sticky, regx.unicode: 对应几个flag
		regx.source：原始字符串，没有首尾两个//。如果用toString()方法的话，会包含//
		regx.lastIndex：可读可写。一开始只用于g；扩展用法见y
		另见 sring.match <url:#r=string.match>, string.replace <url:#r=string.replace>
		资料
			网上一个知识点速查 <url:http://www.jb51.net/article/43190.htm>
			网友整理常用正则表达式 <url:http://www.jb51.net/tools/regex.htm>
	Map
		const map = new Map([ ['name', '张三'], ['title', 'Author'] ]); // 或者new Map()
		map.size // 2
		map.has('name') // true
		map.delete(o) // 删除
		map.get('name') // "张三"
		map.has('title') // true
		map.get('title') // "Author"
	Set <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set>
		阮一峰的介绍 <url:http://es6.ruanyifeng.com/#docs/set-map>
		var set = new Set([1, 2, 3, 4, 4])
		let set2 = new Set() // 空集
		set.add(5)
		set.delete(3) 
		set.has(4) 
		set.clear()
		[...set] // 用set来进行数组去重
	WeakSet和WeakMap
		主要用于全局变量上的内存管理性能上的优化。并非编码上的优化
	[proxy] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy>
	[reflect] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect>
		跟proxy配合使用，取默认行为
	模块化Modules: import/export
		语法理念：导出和导入的书写形式需要保持一致
			例：导入为
			import React, { Component } from 'react'
			导出则应为
			export default React
			export { Component }
		import单例性：多次import只执行一次
		无名导入side effect（缺省加载）
			import 'xxxx'
		导入所有 impot * as
			import * as user from './user.js'; // 随后用user.xx来访问具体导入的成员
			似乎有人建议用这种方式来代替 import R from 'ramda'的形式
		级联写法（从别处导入，再导出）
			export { foo, bar } from 'my_module'
			透传导出
				export * from './api_mock.js'
		import()函数: 好像babel还不支持
		导出的变量都是只读？
			在create-react-app这里是如此，但似乎变量里面的属性，可写
		不支持的写法
			export {...xxx} // 这是动态解构，而es6的模块机制是静态的
			import { a : {b, c} } from ... // 不支持
			export aaa // 可以export const aaa = xxx，但export aaa则是非法语句，应写成export {aaa}
	函数式编程 <?utl:id=js_fp?>
		纯函数: 简单理解为没有状态的函数
			那等同于输出完全被输入决定吗？那如果一个随机数函数呢？感觉这是个灰色地带
		柯里化（Currying）: 部分绑定的完美形态，<url:#r=lodash_curry>
		Hindley-Milner风格的函数类型签名（在注释里标明js函数的类型）
			类似箭头函数的风格，仅供参考
			例：//  replace :: Regex -> String -> String -> String
		知乎用户vczh对其的描述 <url:https://www.zhihu.com/people/excited-vczh/answers>
			函数式编程在使用的时候的特点就是，你已经再也不知道数据是从哪里来了，每一个函数都是为了用小函数组织成更大的函数，函数的参数也是函数，函数返回的也是函数，最后得到一个超级牛逼的函数，就等着别人用他来写一个main函数把数据灌进去了。 
			知乎讨论 <url:https://www.zhihu.com/question/28292740/answer/40336090>
	JSON
		parse
		stringify
			JSON.stringify(p.bp, null, '  ') // 这样可带有缩进, 缺省形式JSON.stringify(xx)得到的结果是没有缩进的，应该是紧凑的一个单行json
	Arson json的升级版 <url:https://github.com/benjamn/arson>
		支持更变态的数据结构，比如环状引用等，Set，Map，Buffer等都能编解码，但似乎Symbol不行
		可以解构导入：import {encode, decode} from 'arson'
	Promise对象
		世界观（promise对象的哲学理念）
			promise世界观是async诞生的基石
			故事
				在之前的js中，异步操作（调用）必要指定回调函数，并且构造时就要指定好，否则就再无机会
				而为何不能晚一步再指定回调呢？这就是promise
				promise对象：对所有的异步操作（广义地，还可以把同步操作也包括进来）进行了抽象，它一旦产生，异步任务便开始启动。但此时它并不打算在任务完成之后，做点什么
				直到你来告诉他，通过其then方法。例: promise.then( x => y )，这时它便知道任务完成之后要做的事情
				如果之后要做的事情，也是promise的性质，便可以写成级联的形式 .then(x => y).then(y => z)...
			promise的对象是数据
				任何形式的promise，不管是同步还是异步，都可以抽象为最终会得到某些数据，比如是一个用户id，为了便于概念提炼，我们可以称之为一个"用户id的promise"
			promise只能返回一个值（只返回一个变量）
				当然如果es委员会愿意，js可以像go一样，令promise也可返回多个值（到了async函数层面需要支持函数也返回多个值），但考量了之后似乎没有这个必要
				限制为一个值也许更利于代码的组织和维护
		初探 <url:./filets/promise.html>
		resolve的接管
			如果resolve的参数是一个promise，则原promise的then将连接新promise
			这个理念常用于promise对象的设计中（比如将一些回调形式的库promise化）, 而在promise的使用中不太需要用到
		then 方法
			伪代码：then( x => y ) -> z 注：这里x为new Promise时传入给resolve的变量（y展开则为函数体, 其返回值为y）
				完整版是then( x => y [, e => ]), 即还可以传一个reject
			then总会又返回一个promise对象，因此可以继续对该promise进行级联处理
		catch 方法
			其实是 then(null, reject)的别名
			catch的返回值与then的返回值性质完全一样（即可以进行级联，接管等）
			如果catch里没有解决问题，应当throw出去，以交由外层的catch来处理
			注：使用nodejs bluebird里的catch能捕获所有异常，即在promise链最后接一个catch，前面的普通js异常都能捕获，实在是太强大！不知道这是否为Promise的规范
			bluebird实现的catch还能filter <url:http://bluebirdjs.com/docs/api/catch.html>
		Promise.all 全部都要完成
			例：Promise.all([p1, p2, ...]).then([f1, f2, ...]=>{})
		Promise.race 取最快完成的那个
			例：Promise.race([p1, p2, ...]).then(最快那个=>{})
		Promise.resolve/Promise.reject 快速就地构建一个 promise 对象
		阮一峰在es6里的介绍 <url:http://es6.ruanyifeng.com/#docs/promise>
		网友讨论如何加超时 <url:https://github.com/matthew-andrews/isomorphic-fetch/issues/48>
	[decorator] 装饰器、修饰器 <url:http://es6.ruanyifeng.com/#docs/decorator>
		提案 <url:https://tc39.github.io/proposal-decorators/#sec-syntax>
		示例: <url:./filets/js/decorator/01.js>
		自己粗略实现的一个autobind <url:./filets/js/decorator/02_autobind_simple_implemetation.js>
			问题：直接按一个包装函数的形式写的，而大概看了下官方的源码，没有返回一个类啊。这是什么操作？得好好研究一下
	iterator迭代器
		世界观：对于forof循环，以及类似[...xx]这样的遍历操作，需要一个统一的迭代器接口来适配
		迭代器接口：{ next() = { value: ..., done: true/false } }
			只要满足如上述规范能不停执行next()的对象，都可称之为迭代器（鸭子类型）
		给对象部署迭代器
			{ [Symbol.iterator]: ()=> 迭代器对象 }
			示例：
				let obj = {
					...
					// 返回一个{ next() }的对象
					[Symbol.iterator]() { return { next() { ...  return { value: .., done: ... } } } } }
	[Generator] 函数（状态机、生成器）
		生成器调用之后，返回迭代器。其具有一些特殊属性
			自迭代: 它自己的迭代器又是它自己（故称为自迭代器）
				一般的迭代器用法通常是部署到主体上，使得主体可以被迭代解构（...或者forof等），而generator生成的迭代器自己就是自己的主体
				function* gen(){ // some code }
				var g = gen()
				g[Symbol.iterator]() === g
			作为async函数的基石
			throw() （未深究）
			return() 直接终结迭代。暂不深究
				据说如果有try catch finally的话，也需要等finally执行完才终止
		function *foo() {
			yield 1
			yield 2
			return 3 // forof循环体不会走到return的值，这符合经典的迭代器半开闭模型 }
		yield* 令生成器可拼装（composable）
			yield* 跟的是迭代体，而generator返回的对象即是迭代器又是迭代体，因此可作为yield*的对象实现generator的组装
			function* gen(){
				yield* ["a", "b", "c"] } // 这时gen()便得到了另一个同样可以遍历数组的迭代器
		示例
			forof
				function *foo() {
					yield 1
					yield 2
					return 3 // forof循环体不会走到return的值，这符合经典的迭代器半开闭模型 }
				for (let v of foo()) { console.log(v) } // 不输出3
			co原理（async函数前身）
				定义一个generator
				在内部逐一yield异步任务的promise
					之所以yield的是promise，是因为promise是js中对异步调用最合适的抽象
				在外部，由一个统一的执行器（比如经典的co）来执行该generator，执行器返回promise
					执行器做的主要事情就是在yield出来的promise的then里，调用状态机的next，这样便把一系列异步任务串了起来，最终完成整个流程
	async函数
		本质上是co模式的语法糖, 但其令语义更直观清晰 <url:./filets/co.js>
		基本语法：const xx = await SomePromise
		返回promise
		使用场合跟普通函数几乎相同
			可自调用
			可作为对象方法
			...
		异常处理
			坑：async函数要想能正确地处理异常，需要所有的异步调用都显式地加上async/await，否则隐式的返回promise的代码里的异常将无法被catch
				如果这个promise也被显式地await的话，可以避免这个问题吗？
	[fetch]
		参考（不能作文档）<url:https://fetch.spec.whatwg.org>
		示例 <url:./filets/js/fetch/>
			有传header的示例
			上传文件的示例
			下载进度
		非常好的一篇讲解 <url:http://louiszhai.github.io/2016/11/02/fetch/>
		返回promise of res:
			res.ok: bool，判断http请求是否成功
			获取http头（headers）
				res.headers.has('content-type'), res.headers.get('transfer-encoding')，这里与koa不同，只能通过方法获取，不能通过对象的属性来得到
		传cookie: (url, {credentials: 'include', ...})
			include: 始终传cookie
			same-origin: 不跨域才传
			omit: 缺省。始终不传
		异常
			在同一条then链上的throw是可以被后面的catch捕获的，但内部如果又另起一个promise的链，则外部promise的catch无法捕获其异常，例：
				: xxx.then(
				: 	throw xx
				: 	yyy.then(
				: 		throw yy
				: 	)
				: ).catch(
				: 	这里可以捕获到xx，而不能捕获yy
				: )
		中断: 使用AbortController和AbortSignal的方式，可以将fetch abort. 要非常新的Chrome才支持
		资料
			这个Api很fetching <url:https://www.w3ctech.com/topic/854>
			传统 Ajax 已死，Fetch 永生 <url:https://github.com/camsong/blog/issues/2>
			mdn <url:https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch>
			可以跨域（需要服务端支持），比如试试这个链接: <url:https://api.github.com/gists>
		坑
			在微软edge浏览器里，不允许将某个header设为空，否则会抛异常
	测试
		Jest <?utl:id=jest?> <url:https://facebook.github.io/jest/> <url:https://facebook.github.io/jest/docs/api.html>
			facebook官方推荐的很强大的测试库，可以测试React和React Native
				据说已经超过mocha等框架成为js测试的最佳选择
				已整合进create-react-app以及react native的cli里
				通过快照来测试react组件，非常方便!
			xx.test.js为测试代码文件. 示例 <url:https://facebook.github.io/jest/docs/getting-started.html#content>
				据说create-react-app还支持识别__tests__/下的文件作为测试代码，但个人暂时不使用该方式
			配置 <url:https://facebook.github.io/jest/docs/getting-started.html>
				create-react-app自动集成jest，不用配置
				如果是node的项目，按照官方文档下载对应的包，普通使用场景不需要任何jest的配置即可正常使用
					babel的配置还是需要的
					自动watch的功能，可借鉴create-react-app项目eject之后的script/test.js，搬到当前项目中来即可
			可以用describe来对用例进行分组 <url:https://facebook.github.io/jest/docs/api.html>
			测试react
				用jest自带的snapshot详见 <url:./filets/jest_react/Link.test.js>
					官网示例 <url:https://facebook.github.io/jest/docs/tutorial-react.html#content>
				Enzyme <url:http://airbnb.io/enzyme/index.html>
					jest的snapshot机制只能检查简单的渲染，对于复杂的ui交互则可以使用Enzyme
			测试异步代码 <url:https://facebook.github.io/jest/docs/asynchronous.html>
				官网文档非常直观，正如你想象中简单！
			mock <url:./filets/jest_async_mock/user.test.js>
				mock机制世界观
					放置mock代码
						在__mocks__目录里放置对应的mock模块。mock模块没有特殊的依赖，保证与目标的导出接口完全一致即可
					指定哪些在mock
						在测试用例（测试代码）里jest.mock('./xx.js')
							据说默认情况下，node的原生的模块只要有mock，不需要指定就会自动mock?
				mock函数（mock工具） <url:https://facebook.github.io/jest/docs/mock-functions.html#content>
					mock的模块只是角色是mock而已，和真正的实现在本质上是没有区别的。但为了更好地测试和统计，jest提供了一些工具来辅助mock模块的实现
					详见代码
			npm t ...或jest ...，即可启动测试
				例：npm t -- -t="haha" 对应 jest -t="haha"
				不建议在git-bash上运行
			命令行参数
				arg（直接参数，非选项） 匹配文件，regex
				-u --updateSnapshot 更新react组件的快照
				-t --testNamePattern=<regex> 匹配名字
					名字指的是每个测试用例的描述字符串，如test('这就是名字', ...)
			坑
				jest里不能用 x=>{}这样的写法，好像test这一行不能写，里面还是可以的
	[webpack] <url:https://webpack.js.org>
		[concepts]
			Entry
			Output
			loaders
			Plugins <url:https://webpack.js.org/concepts/>
		Loaders
			css-loader: css文件的原始loader，通常需要配合其他loader使用（比如style-loader）
			style-loader: 将css loader得到的对象加到DOM里作为一个<script>标签
		[plugins]
			html-webpack-plugin
			clean-webpack-plugin 构建前清空指定某些目录 <url:https://www.npmjs.com/package/clean-webpack-plugin>
				create react app也会清空目录，但是在build.js里调用fs-extra里的函数来清空的。因此没有用到该模块
		webpack命令
			-w watch模式
		[config]
			externals 见webx里的示例
		坑: webpack dev server的host是有限制的。不能随便用域名
			通过看其源码，改其中一个选项即可以放开该限制
		资源
			中文书 <url:http://webpack.wuhaolin.cn/>
			合集 <url:https://github.com/poetries/mywiki/wiki/webpack>
	Babel <url:https://babeljs.io/>
		阮一峰教程 <url:http://www.ruanyifeng.com/blog/2016/01/babel.html>
		插件（plugin、preset）常用的有latest, state-1，详见文档
			Remove console transform 删掉所有的console.* <url:https://babeljs.io/docs/plugins/transform-remove-console/>
			babel-plugin-module-resolver 修改module的路径 <url:https://github.com/tleunen/babel-plugin-module-resolver>
				可以用来模拟一个全局module的机制，适用于快速编写一些编译、部署、测试脚本。不适合生产环境的程序
				示例："plugins": [ [ "module-resolver", { "root": [ "C:/Users/guanghui/react_playground/node_modules" ] } ] ]
					结合官网查看完整例子
		配置示例
			"babel": {
				"presets": [
					"latest",
					"stage-1", "react"
				],
				"plugins": []
			}
			这些presets都要单独安装，比如react对应的npm包为babel-preset-react
		process对象
			似乎会在用于web前端的js模块内注入一个process对象（就像在nodejs里一样访问），其特征是：process.browser = true，可用来区分当前代码是执行在node环境还是浏览器环境
			用于编写同构化（即浏览器和node通用）的代码
		Babel-Polyfill
			通常是补上一些prototype，可以一定程度地解决浏览器兼容性的问题
		坑
			export const json = fetch_fn => async (...para) => { // 猜测是，...para直接透传的话就会出bug？，还是跟async有关
				// eslint-disable-next-line
				para; // 这是babel的bug，经试验，若省略这一行的话，会出现诡异的错误
				const res = await fetch_fn(...para)
				return res.json() }
			[...null, 1, 2] 会报错，而"..."用在对象中，则是不会抛异常的
	js算法
		实现任意数组的'乘': ['a','b','c'],['d','e'] => ["ad", "ae", "bd", "be", "cd", "ce"] <url:./filets/js/algorithm/array_product.js>
	坑
		闭包前面加分号！
			比如写下面的函数，如果前面的分号省略，会当成 a = b(function...) 来解析！
				: a = b
				: ;(function(){
				: 	console.log("haha")
				: })()
		promise结果的作用域
			使用promise的常用套路：
			xx.then(res => {...}).then(res => {...}) 根据代码习惯，会重复res变量名，但这个时候要非常小心注意不同的then里面的res含义不一样！
				曾经就是忽略了这一点，逻辑短路引起BUG
	奇技淫巧
		~~x 将其取整
		base64解码: b = new Buffer(a, 'base64') // 但这个方法已经被node官方废弃，最新版改为Buffer.from(a, 'base64')
			注：解出来是Buffer，而不是string
		arrayBuffer转Buffer: b = new Buffer(new Uint8Array(a))
		取Buffer里的字节的整数形式（字节转整数）: const num = buf[0] & 0xff; // 取自parse gp5的源代码
		高阶函数的"阶"的一个经典应用：计数生成器。计数器处在哪一阶，将决定其计数空间
		Console的高级用法
			node控制台版：console.table <url:https://www.npmjs.com/package/console.table>
			你真的了解 console 吗 <url:https://segmentfault.com/a/1190000000481884>
				涵盖了以下内容：
				console.assert
				console.count: 统计执行的次数
				console.group: 日志折叠
					可以嵌套
				console.table: 打印表格
				console.profile: 性能分析
				console.time: 运行计时
				console.trace: 打印函数的调用堆栈
			console.log和console.dir的微妙区别: <url:http://blog.csdn.net/manyangyangya/article/details/44859685>
			mdn console.table <url:https://developer.mozilla.org/en-US/docs/Web/API/Console/table>
			前端不为人知的一面--前端冷知识集锦 <url:http://www.cnblogs.com/Wayou/p/things_you_dont_know_about_frontend.html>
			Chrome 控制台新玩法-console显示图片以及为文字加样式 <url:http://www.cnblogs.com/Wayou/p/chrome_dev_tool_style_console.html>
			Colors in JavaScript console <url:http://stackoverflow.com/questions/7505623/colors-in-javascript-console>
		获取一个函数各参数的名字！ <url:https://davidwalsh.name/javascript-arguments>
			感觉似乎在做一些依赖注入的时候很有用，但由于babel的不确定性，可能会带来很多隐患，不建议使用
		字符串转数字 +"123"
	资料
		一次围绕setTimeout展开的面试（包含了promise的一些机制）<url:https://zhuanlan.zhihu.com/p/25407758>
		array-like objects（类数组对象）: arguments, dom里的东西
		browserify-as-a-service <url:https://wzrd.in/>
[Node.js] <url:https://nodejs.org/api/fs.html>
	[npm] <url:https://www.npmjs.com/>
		文档 <url:https://docs.npmjs.com>
		[npm i]: npm install <url:https://docs.npmjs.com/cli/install>
			-S: --save
			-D: --save-dev
			阮一峰 npm 模块安装机制简介 <?utl:id=npm_install?> <url:http://www.ruanyifeng.com/blog/2016/01/npm-install.html>
				npm一个最大的弊端就是每一个工程都要单独npm i，效率很低，这个问题的解决官方仍然在探索中，这时社区有一些备选方案：
				npm-cache: npm-cache install代替npm install（从缓存安装）
		[npm un] npm uninstall 卸载模块
			坑： npm似乎不能安全地删除一个模块，比如js-yaml
				虽然自己的程序不依赖它了，但是被内部的其他库（如jest里面的东西依赖）, 这时如果npm un js-yaml之后，这些模块将不能工作
				而这种情况下，npm不会给出任何提示警告
		[npm ls]
			查看模块的依赖树形关系图. 经常执行npm ls能学到很多很多东西
			在此不得不感叹node的社区生态环境实在是比go要好太多
		[npm root] 查看项目目录路径
			-g 也适用
		[npm run ...]: <url:https://docs.npmjs.com/cli/run-script>
			基于npm root，能自动寻找工程的目录，因此在工程的任意子目录里都可以执行npm脚本，非常强大！
			不管在哪个子目录下执行npm脚本，其cwd永远是package.json所在的目录
			阮一峰的教程 <url:http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html>
				亮点：事件钩子，package.json里的配置注入环境变量
				例：console.log(process.env.npm_package_name); // foo
				console.log(process.env.npm_package_version); // 1.2.5
			Npm Run 传入脚本的参数要放到 -- 后面，例：npm run xxx -- a1 a2 -a3
				为什么要这样设计呢？因为npm run本身也有一些参数。因此需要区分开。目前npm run本身的参数暂时只有--silent
		[npm update] 升级、更新模块
			-g 更新全局模块
			--depth 9999 指定更新深度级别，默认不会进行深度更新
				9999是官方文档的示例数字，好像实际中使用9999会导致栈溢出？
		[npm publish] npm发包
			先注册npm账号 <url:https://www.npmjs.com/signup>
			全局环境npm login
			到具体的一个项目npm publish即可
			包里的node_modules默认不会发上来
			一个网友的npm经过打包的示例 <url:https://www.jianshu.com/p/d9fb02a891d9>
		[package.json]
			[peerDependencies] peer dependency 比如两个react组件，依赖两个不兼容的react版本，这种情况下就应该各自把react声明为peer dependency
		[semver] semantic versioning <url:https://semver.org/> <url:https://semver.npmjs.com/>
			记住三大版本号的区别：major, minor, patch
		资料
			如何发布自己的模块到npm
				简书网友（较新） <url:http://www.jianshu.com/p/f5d4c891830f>
				cnblogs较旧的文章 <url:http://www.cnblogs.com/mz121star/archive/2012/11/15/nodejsandnom.html>
			官方文档教程 <url:https://docs.npmjs.com/getting-started/what-is-npm>
			安装慢的解决方法（手动配置registry） <url:http://blog.csdn.net/rongbo_j/article/details/52106580>
				npm install --registry=http://registry.npm.taobao.org xxx
	[官方模块]
		全局对象（即不需要require即可访问的对象）
			__filename: 当前js文件的全路径
			__dirname: 当前js文件所在的目录（不同于cwd，"cd到的目录"）
			注：全局对象并不一定是全局变量，比如__filename等变量对于每个js文件，其值是不一样的
			Process <?utl:id=nodejs_process?> <url:https://nodejs.org/api/process.html>
				stdin和stdout在这里控制，但都是异步的逻辑。网友的同步实现思路 <url:http://blog.csdn.net/kiwi_coder/article/details/8623747>
				process.stdin, process.stdout
				process.chdir(dir) // 相当于cd命令
				process.cwd() // 相当于pwd命令
				判断是否为交互式终端 process.stdout.isTTY
				process.title 设置、读取窗口标题
				process.env 环境变量
					可读可写: process.env.name = 'aaa';
					在windows的里，环境变量名是不区分大小写的。不知道在linux里情况如何
				process.argv 命令行参数
					是一个数组，windows下形如：['c:\\xx\\node.exe', 'c:\\xx\xx\xx.js', ...]
				process.on('uncaughtException', e=>{}) // 全局异常捕获
			encodeURIComponent: nodejs也有这些函数
		[fs] 文件系统 <url:https://nodejs.org/api/fs.html>
			已支持promise
				复数 require('fs').promises
				异步版本略
			读文件
				fs.readFileSync(path[, options])
			写文件
				fs.writeFileSync(file, data[, options])
					fs.writeFileSync(file, data[, options]) // 要求路径（目录）必须存在，即使是使用fs-extra，也要先ensure一下
				fs.writeSync是针对fd的，不常用
				appendFileSync
			重命名、移动文件: rename(oldPath, newPath, callback) renameSync(oldPath, newPath)
			读目录
				fs.readdirSync(path[, options])
					返回string[]
					相对名
			笔记
				realpath / realpathSync 取目录真正绝对路径（主要用于有link的目录，得到其原来的真实路径）
				copyFile(src, dest[, flags], callback), fs.copyFileSync(src, dest[, flags])
				拷贝文件、复制文件(copy file)
					旧的方法：fs.createReadStream('api_real.js').pipe(fs.createWriteStream('x.js'))
				删除文件：unlink, unlinkSync
					注：不支持删除目录
					fs.unlinkSync('_out.zip')
		Assert: node自带assert模块，但其行为总感觉不那么好用. 通常都自己实现
		Child Process 子进程（执行命令） <url:https://nodejs.org/api/child_process.html>
			最原始的api是spawn，其他都是基于spawn的封装
			传标准输入：往subprocess.stdin流里写东西。 可以参考自己写的promisify.js
			exec: 起一个新的shell执行命令
			execFile: 不起新shell
			fork? 还没研究其区别
			execSync 同步版
				返回命令的标准输出, Buffer类型，需要字符串须显式转换:
				const cmd = require('child_process')
				let out = '' + cmd.execSync("svn info https://10.10.10.162/svn/mart/branches/composer | findstr /C:\"Last Changed Rev\"")
		Events事件 <url:https://nodejs.org/api/events.html>
			const EventEmitter = require('events') // 这里导出来的是类!!!
			const eventEmitter = new EventEmitter() // 要实例化才能使用
			注：在webpack的魔力下，在浏览器环境也可以使用
			on和addListener是一样的
		[Path] 路径的操作 <url:https://nodejs.org/api/path.html>
			join: 拼接路径（不一定是绝对路径）
				path.join('/foo', 'bar', 'baz/asdf', 'quux', '..'); // Returns: '/foo/bar/baz/asdf'
			resolve: 拼成绝对路径 path.resolve('/foo', '/bar', 'baz')
			basename: 类似shell里的basename
			dirname: 类似shell里的dirname
			extname('aaa.bb') 取扩展名、取文件后缀名
			sep: 得到分隔符
		Net
			类net.Socket
				localAddress, localPort, remoteAddress, remoteFamily, remotePort
		[http] <url:https://nodejs.org/api/http.html>
			笔记
				创建服务：<url:./filets/node/http/server/01_basic.js>
					req的类是http.IncomingMessage
					res的类是http.ServerResponse
				获取请求方（客户端）基本信息 <url:./filets/node/http/server/02_client_info.js>
					获取请求的http方法：req.method
					获取源ip：通过req.socket来得到
					获取请求的url: req.url. 只得到一个url（详细信息需要用url模块来解析, 比如query等）. host相关的信息应该从header里取
					获取请求的header: req.headers
				设置返回头: 
					设置cookie也是用该方法，例：res.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
				示例 <url:./filets/node/http>
				张占岭 <url:http://www.cnblogs.com/lori/p/3437562.html>
					讲了如何处理post的请求的原始方法
				使用mysql的例子 <url:http://stackoverflow.com/questions/6081117/get-simple-info-from-db-into-a-node-js-http-server-response>
				实现代理
					网友1 目测代码比较简洁 <url:http://www.cnblogs.com/kylindai/p/3570385.html>
				客户端：解压压缩的内容 <url:./filets/node/http/client/gzip.js>
		Url <url:https://nodejs.org/api/url.html>
			url.parse
		Readline 逐行读取流（比如读取标准输入） <url:https://nodejs.org/api/readline.html>
		[Buffer]
			+号操作都会转为string，即使两个Buffer相加
				当然也可以调用toString()方法
			示例 <url:./filets/node/Buffer>
		Stream 流操作 <url:https://nodejs.org/api/stream.html>
			老外（女）教程 <url:https://www.zivtech.com/blog/nodejs-stream-dreams>
			网友教程 <url:https://github.com/substack/stream-handbook>
		Query String
			qs.escape(str)
			qs.parse
			qs.stringify
			qs.unescape(str)
	第三方模块、工具
		[nvm][nvm-windows]
			windows只能用nvm-windows, 直接下载安装包版本，省很多事
		node与npm的优化改进
			npm-cache 从缓存离线安装模块 <url:https://www.npmjs.com/package/npm-cache>
				见 <url:#r=npm_install>
		shell
			[shelljs] 用js的语法来写shell命令神器！ <url:https://www.npmjs.com/package/shelljs>
				可以解构导入：import {cd} from 'shelljs'
				都是同步操作！因此可以直接用强大的js表达式来表示那些难以记忆的gnu命令！在某些场合非常便利！
				支持管道！
				支持终端接管：执行另一个命令行程序时能正常交互（但对回车的处理不太友好，目测可能是node自身的bug）
				阮一峰教程 <url:http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html>
				所有命令的返回格式如下：{code, stdout, stderr, to, toEnd, ...接其他命令的管道操作}
					const {code, stdout} = exec('git status -s')
				ShellString格式：命令执行后取到的stdout, stderr是ShellString类型，它的基本行为与标准string一致，只是多了两个to, toEnd方法
				exec 执行任何命令。支持同步和异步模式，缺省是同步的
					需调研：这个exec相对于child process的exec，会自己吐输出，也就是所谓的终端接管。native的exec如果标准输出超过了缺省值，会报错！很不方便
					但它的原理是什么呢？
				echo 坑：没有silent模式；输出之后不换行
				cd
					可以使用 ~ : shell.cd('~/react_playground') // 在windows中也能用
				cp
					shell.cp('aa/bb.txt', 'cc/dd') // 不加参数
					shell.cp('-R', '~/react_playground/build', img_dir) // 将build目录拷贝
					shell.cp('-R', '~/Desktop/aaa/*', '~/Desktop/bbb') // 这样也能递归，可基于此作一些过滤
					shell.cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp') // 支持多处源
				rm
					shell.rm('-rf', img_dir)
				shx: shelljs的命令行版本的子项目 <url:https://github.com/shelljs/shx>
				坑：
					设置环境变量不要使用shell的命令（尤其在windows中），用shell.env对象代替: shell.env['GOOS'] = 'linux'
					windows中环境变量也不能用echo方法，如shell.echo('%cd%')无效，但shell.exec('echo %cd%')则可以，当然，还可以使用shell.env对象
			opener 跨平台用当前操作系统的ui打开文件、对象 <url:https://www.npmjs.com/package/opener>
				可以作为bin使用，例：opener http://localhost:9090
				注：create-react-app里用的是react自己造的轮子 
					const openBrowser = require('react-dev-utils/openBrowser'); openBrowser(url)
			模拟shell的通配符（如*.js）
				glob 经典版 <url:https://www.npmjs.com/package/glob>
				globby: glob的加强版，promise化 <url:https://www.npmjs.com/package/globby>
					支持更复杂的匹配规则
			展开路径里的~: untildify <url:https://www.npmjs.com/package/untildify>
		命令行参数
			百家争鸣！由此node生态圈的生产力跟go相比的优势可见一斑！比较 <url:https://npmcompare.com/compare/commander,minimist,nomnom,optimist,yargs>
			为了简化并统一参数的逻辑，yargs作了以下限制: 不支持形如mysql -uroot的形式，只支持mysql -u root，前者会被yargs解析为等价于 -u -r -o -t
			Yargs（阮一峰推荐） <url:https://github.com/yargs/yargs>
				const argv = require('yargs').argv
					argv._ 为自由参数数组（不包括文件名本身）
				这是一个很有深度的库，个人感觉其魅力已经远超tj大神的commander，其海盗主题的examples还是很不错的，但其docs里的参考就写得不太清楚，很多地方需要自己摸索
					海盗官网主页 <url:http://yargs.js.org/>
					Docs <url:http://yargs.js.org/docs/>
				阮一峰的教程 <url:http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html>
				支持嵌套对象指定：--aa.bb=xxx
					注：在环境变量中用"__"来指定嵌套, 与命令行中不同，详见文档.env方法的说明
				结合配置文件使用: config方法
					例：var argv = require('yargs').config(require('./cfg.js')).argv 
					注：官方文档说config可以直接传一个json文件的路径，但试验后不行。
					如果config参数为空，则可以通过 --config=cfg.js来达到类似效果
					-- 另支持传入自定义文件格式，这时需要传入一个解析函数，属于特殊用法，不深究
			commander（tj大神杰作） <url:https://github.com/tj/commander.js>
				功能齐全
			minimist（各项数据得分较高）亮点在于它是optimist的精简版 <url:https://github.com/substack/minimist>
		[stdio] 终端
			在终端打印有颜色的字符 
				[Colors] 目前在用 <url:https://www.npmjs.com/package/colors>
					可以通过命令行参数 --color, --no-color 来强制指定颜色开和关，或者是一个FOR_COLOR环境变量（这是看colors的源代码得到的）
						forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
							所以可以设置FORCE_COLOR=1
					text colors
						black red green yellow blue magenta cyan white gray grey
					background colors
						bgBlack bgRed bgGreen bgYellow bgBlue bgMagenta bgCyan bgWhite
					styles
						reset bold dim italic underline inverse hidden strikethrough
					extras
						rainbow zebra america trap random
				Chalk <url:https://www.npmjs.com/package/chalk>
					宣称更环保，create-react-app使用它
			同步读取标准输入 
				readline-sync <url:https://www.npmjs.com/package/readline-sync>
					示例: <url:./filets/readline-sync.js>
					好像还支持按键检测？
				react-dev-utils/prompt: 来自react工具箱，个人觉得不如readline-sync
			一次性读取所有标准输入 get-stdin <url:https://www.npmjs.com/package/get-stdin>
			清除终端
				react-dev-utils/clearConsole
					var clearConsole = require('react-dev-utils/clearConsole');
					clearConsole(); // 即可清屏
			[inquirer] 问卷向导 <url:https://www.npmjs.com/package/inquirer>
				eslint的初始化就是使用该库完成的，非常酷！
			一个交互式的命令系统 <url:https://github.com/dthree/vorpal>
			绘制表格 
				table 有边框 <url:https://www.npmjs.com/package/table>
				text-table 无边框 <url:https://www.npmjs.com/package/text-table>
			进度条 progress <url:https://www.npmjs.com/package/progress>
		日志
			[debug] tj大神作品 <url:https://www.npmjs.com/package/debug>
				node端
					使用debug及其他环境变量
						bash示例: DEBUG_COLORS=on DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
				浏览器端
					localStorage.debug
						localStorage.debug = 'worker:*'
				坑
					babel-node兼容性问题
						使用babel-node的话，在代码中指定环境变量不生效，原因不明
		服务端开发
			[koa] <url:http://koajs.com/>
				世界观：中间件
					剥洋葱的中间件形式
						连路由策略，都可以理解为是通过中间件来实现
					"上下文"包括两个参数：context（上文）, next（下文）
						context虽然中文翻译就是上下文，但事实上其字面翻译应该是"当前文"
					示例 <url:./filets/node/koa/koa0.js> <url:./filets/node/koa/koa1.js>
				获得请求方（客户端）的基本信息 <url:./filets/node/koa/02_client_info.js>
					以下全是代理ctx.request的属性
					标*表示可以被修改
					获取请求的http方法：ctx.method
					获取源ip: ctx.ip
					请求的url信息
						对于 http://www.xx.com:88/aa/bb?x=1&y=2#xxx
						ctx.host: www.xx.com:88
						ctx.hostname: www.xx.com
						*ctx.url:  /aa/bb?x=1&y=2
						ctx.originalUrl: 由于url可被改，故保留一个原始的url
						*ctx.path:  /aa/bb
						ctx.origin: http://www.xx.com:88
						ctx.protocol: http
						*ctx.query: {x:1, y:2}
						*ctx.querystring: x=1&y=2  会去掉#及其后面部分
					请求的header: 以下都一样
						*ctx.header, 
						*ctx.headers
				处理post请求（参见自己 utils/koa_proxy ）
					另见 <url:./filets/node/koa/koa_post_echo.js>
				访问node原始http对象：ctx.req, ctx.res。koa包装过的为ctx.request, ctx.response. 这里有什么扩展？
				重定向 ctx.redirect(url)
					这个时候就不再需要await next()这样的代码了
				关闭服务器: server.close() （官方文档里竟然没有提及）
					const app = new Koa();
					const server = app.listen(3000);  // start
					server.close();   // stop
				错误处理: koa自己的机制好像不太好用
					koa自己提供了一套错误处理的机制，由于不支持自由地throw，故不选择使用。
					现在的做法是在koa_logger里加一个 try/catch
					这样可以处理程序中手动使用throw语句抛出的异常，但仍无法处理系统内部的异常，比如网络错误等，这种情况建议直接让程序停止
					然后使用容器的一些功能令其自动重启，这样比在程序内手工恢复各种资源要简便得多
				手动拼接中间件 <url:./filets/koa/koa_combine_middleware.js>
				-- 参考 --
				ctx
					koa的req和res vs node的req和res
						ctx.request: koa Request
						ctx.response: koa Response
						ctx.req: 与request不同，它为Node's request object
						ctx.res: Node's response object
					ctx.method
					---- request快捷访问方式 -----
					ctx.header / ctx.headers: http头（obj），注：取到的http头的key会全转为小写！
					---- response快捷访问方式 ----
					设置返回码：ctx.status = 200
						如果不进行任何操作，status为404，设置了body之后，会自动更新为200
					ctx.set(): 设置返回的http头，例：ctx.set('X-Response-Time', `xxx`)
					ctx.body: 设置和获取返回的内容
						body可以设置为多种类型：String, Buffer, Stream, Object（会自动转成json），null
					cookie
						ctx.cookies.get(name, [options]) // 取cookie
					放弃koa: ctx.respond = false. koa官方不鼓励这么做. 通常用于一些代理的场合，将处理权移交给其他模块
				app
					app.listen
						app.listen(3000)是http.createServer(app.callback()).listen(3000)的语法糖
				资源
					中间件、框架大杂烩（官方wiki） <url:https://github.com/koajs/koa/wiki>
					快速中文教程 <url:https://github.com/guo-yu/koa-guide>
					另一个类似的中文站点 <url:http://koa.rednode.cn/>，但内容不够详尽
					阮一峰的教程 <url:http://javascript.ruanyifeng.com/nodejs/koa.html>
					廖雪峰的教程 <url:http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001471087582981d6c0ea265bf241b59a04fa6f61d767f6000>
					apebook在线电子书 <url:http://book.apebook.org/minghe/koa-action/hello-koa/what.html>
					简书网友写的一整套解决方案（结合其他框架） <url:http://www.jianshu.com/p/6b816c609669>
					狼叔：Node.js最新Web技术栈（2016年4月） <url:https://cnodejs.org/topic/56fdf66ec5f5b4a959e91771>
					狼叔：Koa 2实用入门 <url:https://cnodejs.org/topic/5709959abc564eaf3c6a48c8>
					koa1教程，仍然有参考价值 <url:https://www.tutorialspoint.com/koajs/koajs_file_uploading.htm>
			[koa中间件]
				koa-logger 官方的一个logger，tj大神也有参与 <url:https://www.npmjs.com/package/koa-logger>
					估计还是自己实现的logger更符合自己的需求，但有空可以研究其代码，发现一些技术细节
				koa-convert 将旧版koa中间件转成可供新版使用 <url:https://github.com/koajs/convert>
					里面还列了一些时髦的router供选用
				Koa-Router <url:https://github.com/alexmingoia/koa-router>
					示例 <url:./filets/koa/koa-router0.js>
					router也带use
						router.use(logger, koa_para) // 注：该方法调用在顺序（位置）也决定了这些中间件生效的位置！
						在一定场合下router可作为koa中间件的一个管家，可用来汇总各类其他中间件
							但有些关键性的中间件仍然适合交给其接管，比如logger，catch等，更适合直接由app来use
							比如router接管logger之后，not found的请求将不被打日志
							另, 不能use koa-static, 原因暂不明
				会话
					[koa-session-minimal] 最先接触到，是koa-session的一个轻量版，支持很多类型的store，但不支持实时更新过期时间（rolling）
					[koa-session] 可以支持自动更新过期倒计时rolling <url:https://github.com/koajs/session>
				文件服务器
					Koa-Static star最高（tj参与贡献）支持koa2 <url:https://www.npmjs.com/package/koa-static>
						是koa-send的一个包装
					[koa-conditional-get]
					[koa-etag]
					Koa-Send 用于应对更灵活的文件服务需求 <url:https://www.npmjs.com/package/koa-send>
						await send(ctx, ctx.path, { root: __dirname + '/public' }) // root缺省情况下，是相对于cwd目录
					其他（未尝试）
						koa-file-server <url:https://www.npmjs.com/package/koa-file-server>
						koa2-file-server 国人写的，仅供参考 <url:https://github.com/TOP-Chao/koa-file-server>
				代理（proxy）
					koa-pixie-proxy 不封口的proxy <url:https://www.npmjs.com/package/koa-pixie-proxy>
						提供了一些很实用便利的方法，详见文档
						坑：由于其调用的是高级的request的方法，做不到完全透明地传送，因此无法代理gzip压缩过的服务内容
					koa2-pixie-proxy: koa-pixie-proxy的koa2版，同样的局限性
					koa-proxy <url:https://github.com/popomore/koa-proxy>
						不支持koa2，需要convert来使用，示例 <url:./filets/koa/koa-proxy.js>
						缺点：
							不能直接代理百度这样的网站
							封口。不能再接其他中间件
					koa-proxies ?
						虽然支持koa2，但功能没有koa-proxy强大，暂时不使用
				koa-compose 将多个中间件合并成一个中间件 <url:https://github.com/koajs/compose>
					koa2配套版本 <url:https://github.com/koajs/compose/tree/next>
					源码分析: <url:./filets/koa/koa-compose.js>
				[koa-body] <url:https://github.com/dlau/koa-body>
					npm install koa-body （最新版本不再需要加@2）
					multipart, urlencoded, json通吃（正合我需要），示例： <url:./filets/koa/koa-body0.js>
					支持文件上传，需要设置{multipart:true}，见koa官方的文件上传示例 <url:https://github.com/koajs/examples/blob/master/upload/app.js>
						koa处理上传文件代码示例: 摘自tonghua里的代码
							async uploadFile(ctx, next) { 
								const {path:p, name} = ctx.request.files.file // 最后字段files.xxx是用户自定义的，只是这里刚好取名为file而已
								// 官方提供的方法是通过流来获取到文件内容，但这里有一个技巧是直接把文件移到所需位置即可（如果移动没有权限可以拷贝）
								await fs.rename(p, d('../../static/img', name))
								ctx.body = {name,}
								await next()
							},
					坑
						对于form-urlencoded和表单的上传（multipart/form-data?）解析出来的结果是不一样的，表单上传的对象会放到fileds、files里
						如果没有开启multipart选项的话，将无法解析到curl -F提交的数据
				koa-bodyparser 另一个koa body库，似乎下载量更高？ <url:https://www.npmjs.com/package/koa-bodyparser>
				koa-better-body （未研究） <url:https://github.com/tunnckoCore/koa-better-body>
					虽然叫better，但不确定是否真的比koa-body要better
				压缩
					koa-compress <url:https://github.com/koajs/compress>
						暂未体验，源代码很少，粗略看了一下，不确定是否会有一些副作用
				阮一峰的koa教程里有讲防止csrf攻击的koa中间件
			Http-Server 一个很方便的http服务器工具 <url:https://www.npmjs.com/package/http-server>
				支持静态文件、代理、cors等。
				代理（proxy）示例：http-server file_dir -P http://localhost:8080, 本地没有的将会被代理过去
				-p Port to use (defaults to 8080)
				不支持压缩
				注：另有其同类产品: serve（为create-react-app官方推荐使用）
			安全、token
				jsonwebtoken ctg的业务所使用的库 <url:https://github.com/auth0/node-jsonwebtoken>
			随机获取一个可用的端口
				portfinder <url:https://www.npmjs.com/package/portfinder>
					支持promise，http-server使用
				detect-port <url:https://www.npmjs.com/package/detect-port>
					create-react-app使用
				最新的create-react-app使用 import {choosePort} from 'react-dev-utils/WebpackDevServerUtils'
					这是为其自己专门量身定制的，如果预设的端口被占用，它会在命令行询问用户是否要自动选择一个端口
			union 早期的http服务器的中间件模式 <url:https://www.npmjs.com/package/union>
				http-server库使用了它，新的项目应该直接建议使用koa，因此暂不深究该库
			Http-Proxy 原始的http代理 <url:https://www.npmjs.com/package/http-proxy>
				被http-server模块使用
				ignorePath: 不自动补齐proxy的路径，这个选项在一些场景下很有用. 缺省为false，即会自动补路径
				另外还有一个辅助模块 http-proxy-rules <url:https://github.com/donasaur/http-proxy-rules>
				另：用于express的中间件 http-proxy-middleware <url:https://github.com/chimurai/http-proxy-middleware>
			ecstatic 传统的http static file server <url:https://www.npmjs.com/package/ecstatic>
				被http-server使用
			corser 跨域资源请求 <url:https://www.npmjs.com/package/corser>
				被http-server使用，见 <url:#r=cors>
			json-server 0代码构建一个restful的api服务器，用于快速测试，另见同一个作者发布的jsonplaceholder <url:http://npmjs.com/package/json-server>
				一个在线公有版 <url:https://my-json-server.typicode.com/>
				坑：不要随便post，会改数据
		客户端工具
			ping <url:https://www.npmjs.com/package/ping>
				就是ping命令的一个wrapper，支持promise
			tcp-ping <url:https://www.npmjs.com/package/tcp-ping>
				类似telnet命令的功能，可以检测tcp服务是否开启
		环境变量
			nodejs的一个流行的模式是通过环境变量来作为程序的配置（该模式是否合理还有待探究），可以使用以下库来方便环境变量的操作
			dovenv 通过.env文件来配置环境变量 <url:https://github.com/motdotla/dotenv>
				和babel-node不能很好地兼容，导致一些库（比如debug）的配置不能生效
		文件系统
			fs-extra: fs的扩展，增加更强大功能，支持promise! <url:https://www.npmjs.com/package/fs-extra>
				官方建议用法：直接代替fs来使用（因为它是fs的超集）
				被create-react-app使用
				copy/copySync 拷贝文件
					注：这里对文件和目录作了限制：只允许file->file和dir->dir
						其实这样原则更清晰，不像shell里cp的使用太灵活经常让人混乱
					await fs.copy(srcFromDir, srcDestDir, { filter : (src, dest)=>{ console.log(`${src} -> ${dest}`) return true } })
					filter: 所有的子目录和子文件都会被传到filter函数，filter函数需要返回true/false，如果目录层级就未返回true，则将不会递归到目录里面
						这样的filter机制比shell要强大得多!
						注：当读到目录时，src和dest里不会包含目录后的'/'或者'\\'字符
						坑：旧版本的filter函数取到的dest不正确，5.*版本之后才修复
					官网摘录
						const fs = require('fs-extra')
						// Async with promises:
						fs.copy('/tmp/myfile', '/tmp/mynewfile')
							.then(() => console.log('success!'))
							.catch(err => console.error(err))
						// Async with callbacks:
						fs.copy('/tmp/myfile', '/tmp/mynewfile', err => {
							if (err) return console.error(err)
							console.log('success!')
						})
						// Sync:
						try {
							fs.copySync('/tmp/myfile', '/tmp/mynewfile')
							console.log('success!')
						} catch (err) {
							console.error(err)
						}
				remove/removeSync 删除文件 支持目录 <url:https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/remove.md>
					await fs.remove('/tmp/myfile')
				emptyDir/emptyDirSync 确保一个目录是空 如果有内容将会清空，如果目录不存在将会创建
				ensureFile / ensureDir / ensureFileSync / ensureDirSync 确保文件、目录存在。如果不需要，可以自动创建任意深度的目录结构
		流操作（stream）
			神器：stream-to-promise <url:https://www.npmjs.com/package/stream-to-promise>
				便于以promise的方式来使用stream，自己实现的koa http代理的中间件全靠该库的帮助
			concat-stream 将stream的数据拷到buffer里 <url:https://www.npmjs.com/package/concat-stream>
		windows-build-tools 安装需要编译的模块的必备工具
		mysql 官方<url:https://www.npmjs.com/package/mysql>
			mysqljs <url:https://github.com/mysqljs/mysql>
				统一一个query，不管是select，insert, update, delete都用该方法
				prepared语句的一些奇技淫巧，比mysql官方的prepare机制更强大！比如可以跟在where或者set的后面：
					query('select * from lesson where ? ', {student:ctx.userid})
						但如果where有多个的话，就不行了
					query(`replace into blueprint set ?`, obj) // 直接将obj展开成类似"aa=1, bb=2"的字符串!
					用数组来表示参数序列「不支持按参数排列的形式」。如果参数序列不是数组，将自动作为第一个问号的替换
					db.query('select id from v_model where id in (?)', [[1,2]]) => in语句将变成 in ('1', '2')
					query自带prepare的功能一步到位，但如果要查看生成的sql，可以先调用mysql.format方法：
						var sql = "SELECT * FROM ?? WHERE ?? = ?";
						var inserts = ['users', 'id', userId];
						sql = mysql.format(sql, inserts);
					坑：
						?序列后的参数，如果有多个，一定要写成数组，如果一个?对应的参数本身就是一个数组，则需要再包一个数组，如[[1,2]]
						只有一个元素的数组，如[1]和1等价
			promise版本有两个
				promise-mysql 网上使用较多的版本 <url:https://www.npmjs.com/package/promise-mysql>
					还有自动重连的机制，其mysql依赖为mysqljs promise依赖为bluebird
					connection（在我代码里通常简写为db）.format -> mysqljs.format
					对于事务(transaction)的处理，可以考虑直接用sql语句来完成，如begin, commit, rollback
					对于并发比较高的情况，可以考虑用连接池来实现
				mysql-promise 功能较弱 <url:https://www.npmjs.com/package/mysql-promise>
		form-data: 表单提交的工具 <url:https://www.npmjs.com/package/form-data>
			使用不是很方便，但在用fetch的时候，有些服务器不支持form-urlencoded，只能使用该库
		promise
			bluebird 用的人更多 <url:https://www.npmjs.com/package/bluebird>
				官方教程 <url:http://bluebirdjs.com/docs/getting-started.html>
			promise 较官方的版本 <url:https://www.npmjs.com/package/promise>
		co <url:https://github.com/tj/co>
			示例 <url:./filets/co.js>
		boom 将http错误友好化 <url:https://github.com/hapijs/boom>
			koa-router的示例里提到了该库
		express（已被koa取代，笔记仅供参考）
			Handle GET and POST Request in Express 4 <url:https://codeforgeek.com/2014/09/handle-get-post-request-express-4/>
		es-checker 查看当前node环境对es6的支持程度
			npm i -g es-checker，直接执行es-checker即可看到结果报告
		node-ssh <url:https://www.npmjs.com/package/node-ssh>
		nodegit git客户端
			坑：在windows上安装需要依赖windows-build-tools，在linux容器上安装的话，则建议翻墙安装，不需要现编译. 如果alpine不行，则使用基本的镜像
		git
			nodegit 操作git的库，支持promise <url:https://www.npmjs.com/package/nodegit>
			simple-git 另一个轻量版的库（依赖git） <url:https://www.npmjs.com/package/simple-git>
		其他
			node-fetch: nodejs的fetch <url:https://www.npmjs.com/package/node-fetch>
				随着babel-node的使用，这些polyfill性质的模块将逐渐不使用
			将英文单词复数化（单数化） pluralize <url:https://www.npmjs.com/package/pluralize>
				没想到这样的库都有...
			删除json里的注释 strip-json-comments <url:https://www.npmjs.com/package/strip-json-comments>
				支持命令行版
	多进程管理，见 <url:./filets/node/multi_process/start.js>
		在这个示例里，主进程被用户中断退出之后，所有子进程也都会退出。不知道在Linux下的行为如何
		这里shelljs非常强大！多亏了它才得以实现多个进程同时在'后台'运行而又能共享标准输出的需求
	babel-node的方案: 用babel-node命令代替node命令
		npm i babel-cli -g
			网友介绍 <url:http://www.cnblogs.com/diligenceday/p/5453523.html>
				文中说还需要npm i babel-cli --save-dev？有待确认
		命令行示例：
		babel-node -e 'console.log("haha")'
		问题：任何指定一个js文件来执行的时候，如何确定node_modules的目录呢？
			是根据package.json来递归找的？还是？总之试验了简单的场景，暂时未遇到问题
	笔记
		终端、命令行参数（见process）<url:#r=nodejs_process>
		既作为模块又是可执行程序（bin）
			opener的代码示例：
			module.exports = opener; // 导出模块
			if (require.main && require.main.id === module.id) // 判断是否在以程序的形式执行
				// 这里利用opener来执行程序逻辑
		据说vscode的调试功能不错，官网 <url:https://code.visualstudio.com/Docs/runtimes/nodejs>
		调试es6（未调通）
			vscode调试配置官方文档 <url:http://code.visualstudio.com/docs/editor/debugging#_launch-configurations>
			网友介绍的针对babel-node的配置，试了但不管用
				1 <url:http://stackoverflow.com/questions/35975656/running-babel-node-in-visual-studio-code>
				2 <url:http://stackoverflow.com/questions/31711286/vscode-debug-es6-application>
			网友说用babel-node的话，对vscode的配置会更麻烦 <url:https://medium.com/@katopz/how-to-debug-es6-nodejs-with-vscode-8d00bd6c4f94#.b746rvekp>
		不能用Ctrl+C停止服务进程
			一直没找到真正原因
			线索：
				曾试过关掉一个gitbash的窗口（跟要执行的进程同一个目录），删掉一个npm出错的日志，就好了... 好了之后，再打开gitbash也不影响了[2017/4/19 14:57:14]
				但后来发现，这根本没有规律。
				好像注销之后可以恢复
				算了，还是使用gitbash吧
		vscode调试es6
		调用windows api/com: 
			用node-ffi（好像被重命名为ffi）
				stackoverflow上的讨论 <url:https://stackoverflow.com/questions/15775201/call-windows-api-from-node-js-msg>
			好像还有一个win32ole的包用来调用com对象 <url:https://www.npmjs.com/package/win32ole>
				一个教程 <url:https://helloacm.com/using-com-object-in-nodejs/>
[awesome js] 第三方库
	[lodash] <url:http://underscorejs.org/> <url:https://lodash.com/docs>
		Lang
			_.isArray
			_.isFunction(value)
			_.isObject
				数组也是object: _.isObject([1, 2, 3]) // true
				isObject(null) // false
			_.cloneDeep 是可以处理环形数据结构
		数字、数值
			_.isEqual(a, b)
			_.clamp(number, [lower], upper)
				_.clamp(-10, -5, 5); // => -5 _.clamp(10, -5, 5); // => 5
		数组
			_.without 删除元素（返回新数组，使用简单的相等比较）
			_.pull类似without，区别在于其修改原数组
			_.remove 修改原数组，传入一个函数作为删除条件（跟_.filter类似吗）
			_.flatten _.flattenDeep _.flattenDepth 扁平化
			_.union 求并集
				除了合并，还有去重的功能
				_.union([3,2,1,1], [1,2,5])
				[3, 2, 1, 5]
				会保持元素出场的顺序
			_.findIndex, _.findLastIndex 类似find，但返回的是index
				_.findIndex(array, [predicate=_.identity], [fromIndex=0])
			_.indexOf 则是findIndex的简单版
			去杂
				_.compact, 清洗去掉false（falsy, falsey）的元素: false, null, 0, "", undefined, NaN
			截取
				_.head、_.first 取第一个元素（原数组元素级别）
				_.tail 去掉第一个元素（与原数组同级）
				_.initial 去掉最后一个元素（与原数组同级）
					如果只有一个元素，则该元素会作为"最后一个元素"（_.last）而被去掉，返回空数组，即_.initial([1]) => []
					可以接受非法输入，不符合逻辑的输入，均返回[]: 很利于编写高容错性代码
				_.last 取最后一个元素（原数组元素级别）
		对象
			_.get 对象取值，任意深度，支持缺省，省下处理抛异常的麻烦
				var object = { 'a': [{ 'b': { 'c': 3 } }] };
				_.get(object, 'a[0].b.c'); // => 3
				_.get(object, ['a', '0', 'b', 'c']); // => 3
				_.get(object, 'a.b.c', 'default'); // => 'default'
			_.set 对象设值，与_.get对应（会修改原对象）
				_.set(object, 'a[0].b.c', 4)
				_.set(object, ['a', 'b', 'c'], 4)
				对于不期望修改原对象的情况，可以用assign、defaults等方法
				注意：
					如果object不是一个对象，修改无效，直接原值返回
			_.unset 删除属性，会修改原对象。容错性强
				只支持删除一个路径
				_.unset(object, ['a', '0', 'b', 'c'])
				_.unset(object, 'a.0.b.c')
			_.at: _.get的批量版（取一系列的值，返回数组），这样好像就不支持缺省值了吧？
				var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
				_.at(object, ['a[0].b.c', 'a[1]']); // => [3, 4]
			_.keys: 取对象的属性列表
				该方法取不到方法列表，要实现这一点可参考自己封装的uniquer.js里的代码
			_.keysIn
				对应for in
			_.assign、_.assignIn, _.extend, _.merge, _.mergeWith系列
				_.assignIn（别名_.extend）的区别好像是其只考虑own and inherited source properties
				_.merge 深度拷贝（递归），会改变原对象，但不会修改参数
					能处理环路的数据结构！
					坑：
						通常用merge是用于的场景，但对于数组是不能实现覆盖的，因此使用时要特别注意
						let a = {a:[1, 2]}
						let b = {a:[2]}
						_.merge(a, b) // => {a:[2,2]}
				注：以上函数都修改原对象
			_.defaults, _.defaultsDeep
				与assign同为对象叠加的方法，但其逻辑是：仅当目前没有对应值时，才选择覆盖
				处理react的props时，不能正常工作，需要wash
				注：会修改原对象
			_.pick、_.pickBy 选出部分属性
				_.pick(object, ['a', 'c'])
				_.pick(object, 'a', 'c')
				pickBy(obj, (val, key) => bool )
				注：对于没有的属性，将会忽略（而不是pick出一个undefined值来）
			_.omit 去掉部分属性
				_.omit(object, ['a', 'c'])
				_.omit(object, 'a', 'c') 
			_.omitBy
			_.keys 返回数组
			_.mapKeys, _.mapValues 给keys或者values变换
				可以用于数组，可将数组转为对象
				_.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) { return key + value; }) // => { 'a1': 1, 'b2': 2 }
					注：mapKeys无法减少项目的个数
				var users = { 'fred':    { 'user': 'fred',    'age': 40 }, 'pebbles': { 'user': 'pebbles', 'age': 1 } }; 
				_.mapValues(users, function(o) { return o.age; }); // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
				_.mapValues(users, 'age'); // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
			_.has / _.hasIn 判断是否有某个属性（支持深度路径）
				hasIn检查祖先
				如_.has(object, 'a.b')
		集合（对象、数组都适用）
			_.includes 是否有某个元素[废弃underscore里的_.contains]
				数组和对象都适用（对象只检查key，不查value），还可用于字符串
			_.each（_.forEach）
			_.isEmpty. 对于{}和[]都返回true
			lodash里没有all和any，只有some和every
			_.some 返回bool（underscore里有别名 _.any）
				_.some([null, 0, 'yes', false], Boolean); // => true
				对于空集，_.some返回false
			_.every 与some相对（underscore里好像有别名，_.all）
				「坑」「注」：为了与some的逻辑相对称，_.every(空集合)为true！！
			_.groupBy （与自己的group的思路有一些交集，但定位不完全一样）
				_.groupBy([6.1, 4.2, 6.3], Math.floor);
				// => { '4': [4.2], '6': [6.1, 6.3] }
				// The `_.property` iteratee shorthand.
				_.groupBy(['one', 'two', 'three'], 'length');
				// => { '3': ['one', 'two'], '5': ['three'] }
			_.filter 筛选（有点类似sql的select）
				反向过滤，用_.reject
				可以操作对象，但返回的结果一定是数组（类似_.map的机制）
				注：哪怕是筛选出来之后只有一个结果，仍然是返回数组，这跟sql的select一样!
				如果要返回对象，可以使用pick、pickBy
				: var users = [
				: 	{ 'user': 'barney', 'age': 36, 'active': true },
				: 	{ 'user': 'fred',   'age': 40, 'active': false }
				: ];
				:
				:	支持一些快捷方法
				: _.filter(users, function(o) { return !o.active; });
				: // => objects for ['fred']
				:
				: // The `_.matches` iteratee shorthand.
				: _.filter(users, { 'age': 36, 'active': true });
				: // => objects for ['barney']
				:
				: // The `_.matchesProperty` iteratee shorthand.
				: _.filter(users, ['active', false]);
				: // => objects for ['fred']
				:
				: // The `_.property` iteratee shorthand.
				: _.filter(users, 'active');
				: // => objects for ['barney']
			_.reject
			_.find 类似filter，但只找第一个
			_.findLast 类似find，但从后开始找
			_.size 元素个数，如果是字符串，取长度，其他返回0
			[_.map]
				缺省调用，如：_.map(a)返回a的克隆
				lodash的map和数组原生的map相比，其容错性更强，还能兼容arraylike
				非对象，返回[]
			随机取一个 _.sample
				_.sample({a:1, b:2}) // 得到1或者2
			随机取指定个 _.sampleSize
			[废弃_.pluck] 用 _.map代替
				var objects = [{ 'a': 1 }, { 'a': 2 }]
				_.map(objects, 'a'); // → [1, 2]
		函数
			_.curry <?utl:id=lodash_curry?> 非常强大的柯里化！支持直接拿 _ 对象来作占位符！
				它的神奇效果实在是太令人兴奋了! 相见恨晚的感觉.  _ 终于亲自派上了用场! 
				var abc = function(a, b, c) { return [a, b, c]; };
				var curried = _.curry(abc);
				curried(1)(2)(3);
				// => [1, 2, 3]
				curried(1, 2)(3);
				// => [1, 2, 3]
				curried(1, 2, 3);
				// => [1, 2, 3]
				// Curried with placeholders.
				curried(1)(_, 3)(2);
				// => [1, 2, 3]
				注：一个参数被传了undefined和"该参数没传"等价
				因此，curried() === curried，进而curried()()()...() === curried，只有被传入不是undefined的参数之后，函数才会被降阶
				这里和天然的高阶函数的行为不一致：柯里化后的函数用法更灵活强大，同时也带来了这些坑
			据说 lodash/fp 模块还提供了更强大的函数式编程的工具 <url:https://github.com/lodash/lodash/wiki/FP-Guide>
				但好像fp里的方法在主模块（即_）里也有，比如fp.compose等同于_.flow（没有_.compose）
			_.flow, _.flowRight
			_.memoize（具有cache的函数）
				_.memoize(func, [resolver])
			_.debounce, _.throttle
				debounce像友善地等电梯（如果一直有人来，电梯可能一直走不了），throttle像班车（固定时间一班，到点即走不等人）。另外可以参考rxjs
		字符串
			_.trim, _.trimEnd, _.trimStart
				_.trim('  abc  '); // => 'abc'
			_.camelCase
			_.capitalize('FRED'); // 转成首字母大写
				// => 'Fred'
		Util: 一些函数生成器，通常用作map等函数的functor
			_.property
			_.identity
	[ramda] <?utl:id=ramda?> <url:http://ramdajs.com/docs/>
		还有一个附加的扩展包：Ramda Adjunct <url:https://github.com/char0n/ramda-adjunct>
		ramda也有占位符R.__
		阮一峰强烈推荐！支持在线测试: 首页 -> try ramda
		有一个自动得到ramda解决方案的库（ramda解题机器人） <url:https://github.com/bahmutov/rambo>
			const solution = solve([1, 2, 3, 4], [5, 6, 7, 8])
			console.log(solution.name) // "R.map(R.add(4))" 可以把解法给试出来！！！通过穷举法！
		cookbook 用实例来讲解使用ramda进行函数式编程的技巧 <url:https://github.com/ramda/ramda/wiki/Cookbook>
		R.curry 与lodash的curry类似
		R.curryN 类似curry，用于curry化参数不确定的函数
		R.map
			与lodash的区别:
			_.map({a:1, b:2}, v=>v+1) // [ 2, 3 ]
			R.map(v=>v+1, {a:1, b:2}) // { a: 2, b: 3 }
			对于非对象，得到[undefined]
			注：函数只能接收一个参数！！不能接收(key, value)
		intersperse 给数组元素间插一个分隔元素
			R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
		filter, reject: 类似lodash对应的功能, 但结果会保留原来的对象或者数组形式，但只能访问value
		R.pick, R.omit: 仅针对对象，因此可以访问到key和value
			跟lodash有点类似，但序列只支持用数组表示
		transduce, into <url:./filets/ramda_transduce_into.js>
		groupBy (fn, arr)=>{res1: [...], res2: [...], ...}
		reduceBy 为 groupBy的一般化，可自定义reduce算法
		groupWith 将数组按一定规则切块
		converge 聚焦 <url:./filets/ramda_converge.js>
		--- 函数式 ---
		compose, pipe: 由于其特殊使用场景，其结果不会柯里化
			注：真正理解了ramda之后，才真正理解ramda.compose的精髓！一般不会有使用pipe的场景
		tap 分线器（用于类似接入测量仪、电流表等的功能，不影响原来的数据流动，常用于打日志，或者是数据分流（像shell里的Tee命令））
			var sayX = x => console.log('x is ' + x); // 定义一个日志函数
			R.tap(sayX, 100); //接入日志函数，原来的数据原封不到，区别只是多打出了日志：logs 'x is 100'
		R.flip 将函数的前两个参数替换
	[rxjs] "lodash for events" <url:http://reactivex.io/rxjs/>
		rx支持多语言，其大主页: <url:http://reactivex.io/>
			在v6没完善之前，旧版的文档还得查 <url:http://reactivex.io/rxjs/manual>
		v6的划时代意义: 更纯，方能发挥函数式的威力
		[fromEvent]
			const clicks = fromEvent(document, 'click')
		[fromEventPattern] 根据提供addHandler/removeHandler来构建obserable
		[operators] rxjs
			[map]
			[flatMap] 先map->observable再flat
			[pairwise] 每人拉上其后面的一位 <url:https://rxjs-dev.firebaseapp.com/api/operators/pairwise>
		资源
			教程 <url:https://www.learnrxjs.io>
			旧版笔记
				Observable: 通常称为"源"
					「官方的test代码是一个非常形象的说明文档」
						以debounceTime为例 <url:http://reactivex.io/rxjs/test-file/spec-js/operators/debounceTime-spec.js.html#lineNumber5>
						具体符号的定义还未深究
					do: debug神器
					delay: 所有事件延迟指定时间
					reduce: 类似于array的reduce. <url:http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-reduce>
						记忆方法，所谓reduce，一定是要把东西'减少'，才能叫reduce!
						reduce((累积值, 当前值)=>新的累积值)
					scan: 类似reduce（参数完全同），但将每次累积的值emit出来 <url:http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-scan>
					mergeScan: 类似scan，区别为参数是一个observable的变换, 先scan再merge
					filter: 过滤。类似lodash的filter
						partition: 类似filter，但把剩下的那部分也拿来有用
					distinct: 去重（全局去重）
						distinctUntilChanged 局部去重
					partition: 同filter，但返回两个结果：合格的和不合格的都返回
					bufferToggle: 类似水龙头的一开，一关的一杯一杯装水动作
					window / windowToggle : 类似buffer，但拆成多路流，而不是数组
					startWith 在前面插入一个值
					多路合并
						switch: 新路直接覆盖旧路
						exhaust
					限流
						debounce: 类似等电梯案例，特点是如果陆续来人，电梯有可能永远没有机会走
						debounceTime: 直接传入时间间隔参数来debounce（原始debounce方法需要传一个流）
						throttleTime
						audit / auditTime: 跟throttle类似，暂不深究
						sample / sampleTime
				mumuzhenzhen的专栏教程 <url:https://segmentfault.com/a/1190000004293922>
					翻译自 The introduction to Reactive Programming you've been missing <url:https://gist.github.com/staltz/868e7e9bc2a7b8c1f754>
					文末系统推荐的文章似乎也不错
				汇智网的教程 <url:http://cw.hubwiz.com/card/c/569d92e3acf9a45a69b05154/1/1/3/>
				与react结合
					手写代码时，要特别注意避免发生事件重复订阅的情况，尤其是与ref结合使用时，因为react的ref经常会允许多次调用
					用redux的风格来将rxjs应用到react上
						Use RxJS with React, 这是一个很厉害的思想 <url:https://michalzalecki.com/use-rxjs-with-react/>
						Use RxJS with React <url:http://slides.com/michalzalecki/use-rxjs-with-react>
					rxjs-react-component 将react的事件转成observable的形式 <url:https://www.npmjs.com/package/rxjs-react-component>
						谨慎使用! 感觉使用的人不多
				旧版安装事项：官方的安装说明不适用于react, 直接npm i rxjs，而非官方文档上的npm i rxjs-es!!
					rxjs-es在create-react-app上不能编译
				示例
					who to follow demo <url:./filets/rxjs/who_to_follow>
	jscodeshift js代码批量自动修改神器！<url:https://github.com/facebook/jscodeshift>
		网上教程 <url:https://www.toptal.com/javascript/write-code-to-rewrite-your-code>
		另一个网上的示例 <url:https://glebbahmutov.com/blog/jscodeshift-example/>
		一个改注释的例子 <url:http://astexplorer.net/#/gist/8c7d9f81226bbbdee5d9c7a2468ddaa0/c3d93b44e2bf90e0ff2553ec1c8d85dd2daf807e>
		自定义逻辑完成代码的自动修改. 主页有大量的示例供参考，实在是太赞了！
		其是对recast的一个包装，recast就是一个用来批量修改js代码的库 <url:https://github.com/benjamn/recast>
		作者对其背景的讲解 <url:https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb>
	esnextbin 一个直接在浏览器端做前端项目的库 <url:https://github.com/voronianski/esnextbin>
	Flow <url:https://flow.org/>
	[mathjs] 处理数学的js库 <url:http://mathjs.org/docs/getting_started.html>
		[fraction]
			math.fraction('1/3')   // Fraction, 1/3
			math.fraction(2, 3)    // Fraction, 2/3
			math.fraction('0.(3)') // Fraction, 1/3
	astexplorer 一个强大的语法树解析库 <url:http://astexplorer.net/>
		支持多种语言的语法树的解析
		源码 <url:https://github.com/fkling/JSNetworkX> 
	PACE.js 页面loading效果的解决方案（页面加载）<url:http://github.hubspot.com/pace/>
	[D3] <url:https://d3js.org/>
		世界观：d3是一个很庞大的体系，但它并不是一个庞大的专制性的框架，而是被拆分成了许多个工具，允许你在任何框架中使用
			d3并没有彻底拥抱npm以及es6的模式，因此其官网的教程还是传统的js引入的方法（像传统的jquery全家桶）
			但由于它的各子模块还是放到了npm，给已经转入es6的用户带来了极大的便利
			以下笔记按npm的模块进行整理，基本上不影响传统风格示例代码的学习
		最近版本的在线js <script src="https://d3js.org/d3.v4.min.js"></script>
		github官方教程 <url:https://github.com/d3/d3/wiki/Tutorials>
		gallery 很多很酷的demo <url:https://github.com/d3/d3/wiki/Gallery>
		api参考 <url:https://github.com/d3/d3/blob/master/API.md>
		示例见: <url:./filets/d3_example> 
		d3-array 与lodash有些交集，但仍有一些独家工具（数学统计层面） <url:https://github.com/d3/d3-array>
			extent 求数组的范围，即[min, max]
			mean 求平均值（同lodash）
			median 中位数（lodash没有）
			quantile 数学含义未研究
			variance 方差
			deviation 偏差
			...
		d3-interpolate 插值算法（的构造器） <url:https://github.com/d3/d3-interpolate>
			为了标准化，插值的定义域都在0 ~ 1区间，但真正使用时可超过这个范围（越界）
				var i = d3.interpolateNumber(10, 20);
				i(0.0) => 10,  i(0.2) => 12, i(-1) => 0, i(2) => 30
			interpolateZoom 跟zoom相关的插值
				其数据的格式为[ 中心坐标cy, xy, 尺寸（一个值）w ]
		d3-scale 插值的进一步封装 <url:https://www.npmjs.com/package/d3-scale>
			其实是一个映射，将真实的数据，映射为用于可视化的值。比如将人口的比例映射为柱状图显示的长度
			import {scaleLinear} from 'd3-scale' // 注：不支持 import ds from 'd3-scale'，然后使用ds.scaleLinear的写法
			官方推荐作者写的介绍文章 <url:https://medium.com/@mbostock/introducing-d3-scale-61980c51545f>
			linear示例 <url:./filets/d3_example/1_bar_chart/main.js#d3-scale>
			附带几个常用的调色板 d3.schemeCategory10, d3.schemeCategory20, d3.schemeCategory20b, d3.schemeCategory20c
				其实就是几个预置的数组而已，和ordinal scale配合使用
			d3.scaleOrdinal() 构造一个离散的scale，定义域是整数序列
		d3-scale-chromatic 更全面的调色板<url:https://github.com/d3/d3-scale-chromatic>
		d3-hierarchy 层级结构（树形结构、树状） <url:https://github.com/d3/d3-hierarchy>
			d3.hierarchy(data[, children]) 传入一个数据源对象，返回一个解析过的层级对象
				children参数用来指定获取子节点的函数，缺省为 function children(d) { return d.children; }
				解析后的对象，拥有大量实用属性和方法（详见文档）
					之前的C++时代还尝试自己写过json_count之类的函数还很有成就感，现在直接被d3秒杀！
			d3.stratify 示例见 <url:./filets/d3_example/dendrogram/main.js#stratify>
			d3.cluster() 用于树形布局。（得到一个cluster对象，布局函数, 见下）
				cluster布局的特点是所有叶子节点都在最底层
				cluster(root) 传入一个层级数据结构，给其注入布局坐标
				示例 <url:./filets/d3_example/dendrogram/main.js>
			d3.tree() 与cluster的区别是tree更加紧凑，同一depth节点在同样的高度
			d3.pack() 用于圆球布局（circle packing） <url:./filets/d3_example/circle_packing/main.js#d3.pack>
				必须要使用node.sum方法
			node 是一个递归的结构
			node.descendants() 返回包括自己在内的所有子节点平铺的一个数组 <url:./filets/d3_example/dendrogram/main.js#descendants>
			node.sum(...) <url:./filets/d3_example/circle_packing/main.js#sum>
		d3-format 显示格式化 <url:https://github.com/d3/d3-format>
			详见文档，很强大的格式化工具库，比如 1234 格式化为 1,234
		d3-selection 跟jquery重叠相对最多的一块 
			selection.on('click', fn(d, i, ...){ this为当前dom元素 }) 事件响应
			selection.call 对selection调用一个函数，使用其call方法的意义在于实现链式调用
		d3-transition
			最简单示例： d3.select("body").transition().style("background-color", "lightblue")
			transition.duration(2000)
			transition.ease(timing_function) 指定时间函数
			transition.tween 自定义变换时间轴的行为
				区分于前面的类似于css transition的简便方法，tween可以通过流出时间插值，让用户根据时间插值来决定当前这一刻（这一帧）要处于什么状态
				这个思想和react motion非常接近
		d3-force <url:https://github.com/d3/d3-force>
		d3-drag <url:https://github.com/d3/d3-drag>
		d3-shape <url:https://github.com/d3/d3-shape>
		资源
			十二月咖啡 国内的不错的站点 <url:http://www.decembercafe.org/>
				做了很多酷炫的ui动画工具，其中有一个调色教程很赞
			ourd3js <url:http://www.ourd3js.com/>
			作者的代码博客
				Let’s Make a Bar Chart 柱状图1 <url:https://bost.ocks.org/mike/bar/>
				Let’s Make a Bar Chart, II：引入svg，以及ajax请求数据 <url:https://bost.ocks.org/mike/bar/2/>
				Let’s Make a Bar Chart, III: 引入坐标轴 <url:https://bost.ocks.org/mike/bar/3/>
				Three Little Circles <url:https://bost.ocks.org/mike/circles/>
				How Selections Work <url:https://bost.ocks.org/mike/selection/>
				How selectAll Works <url:https://bl.ocks.org/mbostock/5369146>
				Collapsible Tree 可折叠的树 <url:https://bl.ocks.org/mbostock/4339083>
				Tidy Tree（其实就是dendrogram） <url:https://bl.ocks.org/mbostock/4339184>
			Scott Murray: D3 Tutorials <url:http://alignedleft.com/tutorials/d3>
				About these tutorials <url:http://alignedleft.com/tutorials/d3/about>
				Fundamentals <url:http://alignedleft.com/tutorials/d3/fundamentals>
				Setup <url:http://alignedleft.com/tutorials/d3/setup>
				Adding elements <url:http://alignedleft.com/tutorials/d3/adding-elements>
				Chaining methods <url:http://alignedleft.com/tutorials/d3/chaining-methods>
			Adjustable Link Strength <url:https://bl.ocks.org/mbostock/aba1a8d1a484f5c5f294eebd353842da>
			Mike Bostock’s Blocks <url:https://bl.ocks.org/mbostock>
			Force Dragging I <url:https://bl.ocks.org/mbostock/2675ff61ea5e063ede2b5d63c08020c7>
			Force Dragging III <url:https://bl.ocks.org/mbostock/ad70335eeef6d167bc36fd3c04378048>
			Force-Directed Tree <url:https://bl.ocks.org/mbostock/95aa92e2f4e8345aaa55a4a94d41ce37>
	[AntV] 阿里的d3山寨版 <url:https://antv.alipay.com/zh-cn/index.html>
	ESLint <url:http://eslint.org/>
		参考 <url:http://eslint.org/docs/user-guide/getting-started>
			先全局安装，然后到具体项目目录eslint --init，会自动将eslint locally安装
			eslint --init的命令行向导界面做得很赞！（虽然生成的配置完全不能用）
			如果要在package.json里配置，加到eslintConfig字段
			真正使用时，使用局部安装到版本：node_modules\.bin\eslint .
		坑
			其默认的配置是完全不能用（连箭头函数都不能识别），但把create react app的配置（其实是在eslint-config-react-app模块里）拿来是可以直接用的
	表单
		form-urlencoded <url:https://www.npmjs.com/package/form-urlencoded> 
			官方querystring库的加强版，官方库不能处理多级对象，比如 {a:{b:1, c2}}，而这个库则可以
			目前在用，示例：
			var formurlencoded = require('form-urlencoded');
			var obj = {
				str : 'val',
				num : 0,
				arr : [3, {prop : false}, 1, null, 6],
				obj : {prop1 : null, prop2 : ['elem']}
			};
			console.log(formurlencoded(obj));
			// str=val&num=0&arr%5B%5D=3&arr%5B%5D%5Bprop%5D=false&arr% 
			// 5B%5D=1&arr%5B%5D=null&arr%5B%5D=6&obj%5Bprop1%5D=null&o 
			// bj%5Bprop2%5D%5B%5D=elem
	Immutable  <url:https://facebook.github.io/immutable-js>
		通用方法
			.toJS()
		需要用其自带的.equals或者Immutable.is函数来判断相等性
			例：
			const xx1 = IMap({ b : IMap({ 
				key : 1,
			}), a: 'fuck'})
			const xx2 = IMap({ a:'fuck', b: IMap({ 
				key : 1,
			}), })
			console.log(xx1.equals(xx2)) // true
			: 如果key下面的value是对象，要必须要将其immutable化
		github <url:https://github.com/facebook/immutable-js/>
		Map
			map1.set('b', 50);
			map1.get('b');
			例：这里不会进行深度immu化，m1下面的对象仍然保存原始的raw object形式
			Map({ 
			m1 : {
				type : 'mysql',
				x : 150,
				y : 100,
			})
		据说有一个devtool，在weavescope的源码里有看到，还未用过
			import installDevTools from 'immutable-devtools';
			installDevTools(Immutable);
	immutability-helper
	memoize-one 只记忆上一次调用 <url:https://www.npmjs.com/package/memoize-one>
		lodash的memoize有点复杂，很多时候这个库更实用
	Freezer.js: 另一个immutable的方案 <url:https://github.com/arqex/freezer>
		最大优势：很方便地更新一个很深的节点数据
		比immutable.js更轻量 与React结合时，相当于取代react的state，setState的机制
			它本身有store的概念，似乎有一定的和redux结合的可能性，但有一些文档则是建议用freezer代替flux(or redux)？有待好好研究 <url:https://medium.com/@arqex/react-the-simple-way-cabdf1f42f12#.g41jpw16v>
		世界观：store和state（data），store（全局唯一，存放data），data从store获取, immutable
			store = new Freezer({..初始状态..}) // 构造函数的参数一定是个对象（至少是{}），缺省参数的话会报错
			state = store.get() // 获得data
			state.set(key, value)或者state.set({...}) // 后者类似react setState
				该调用改变了store里的数据，返回新的修改后期望得到的变量对象，但原状态的引用者（这里是state），仍然保持不变（immutable）
				state.reset({...}) 类似react replaceState
				对象删除属性：obj.remove('a'), obj.remove(['a', 'b'])
				「注」不支持递归深度set
			store.on('update', function( currentState, prevState ){ }) // 监听state变化，作为取代react setState机制的必要条件之一
			store.set(another_state) // 重置data，注意与data.set相区别
			state.pivot() 对于需要一次性更新多处地方的场景，非常有用，例
				store.get().people.pivot().John.set({age: 30}).Alice.set({age: 30})
				注：在下一个tick时，pivot会被自动清除，使其不影响后面的使用
					即，上例中如果把两个set操作直接断开来执行的话，是不能正常工作的
			state.remove 删除属性
				freezer.get().remove('d').remove(['b', 'c'])
		坑
			与某些库结合使用时，需要净化数据（使用toJS()方法，或者是用modash里的wash）。比如_.merge，如果不wash将得不到正确的结果
	时间操作
		day.js <url:https://day.js.org/en/> YYDS!
			比date-fns好用得多！
		date-fns 虽然dan大神推荐过，但是用起来还是复杂，而且体积又大，对小程序不友好 <url:https://date-fns.org/>
			import { format } from 'date-fns'
			format(new Date(), 'yyyy-MM-dd', )
		[deprecated] moment 曾经较受欢迎 <url:http://momentjs.com/docs/#/displaying/format/>
			import moment from 'moment'
			const tag = moment().format('YYYYMMDD_HH.mm') // 坑：注意是moment()，而不是直接用moment!
	jsmind 思维导图js库
	cookie操作 js-cookie <url:https://www.npmjs.com/package/js-cookie>
	颜色操作 color <url:https://www.npmjs.com/package/color>
		功能非常全面，可以对颜色进行各种变换，运算，比如求亮度，求灰度，颜色混合等
	url解析
		query-string <url:https://www.npmjs.com/package/query-string> <url:https://github.com/sindresorhus/query-string>
			暂时用的是这个，github star较高
		querystring: 这是将node内建的querystring模块可移植化. 似乎更应该被使用？<url:https://github.com/Gozala/querystring>
	yaml
		js-yaml: 目前正使用 <url:https://www.npmjs.com/package/js-yaml>
			坑！：我已经修改了其代码！见自己folk的github地址，使用该库时要注意！
			从npm文档上看，是针对nodejs的，但目前前端也正在使用未发现问题
			以抛异常的方式处理错误
			yaml.dump(obj[, opts]) // 从对象导出yaml
			yaml.load(str[, opts])
		yamljs <url:https://www.npmjs.com/package/yamljs> <url:https://github.com/jeremyfa/yaml.js>
			使用dump的时候，好像有bug 2016年12月23日
		yaml <url:https://www.npmjs.com/package/yaml>
	jszip 前后端通用的压缩库（打zip包和解zip包） <url:https://stuk.github.io/jszip/>
		支持直接从前端下载
	dom-align <url:https://github.com/yiminghe/dom-align>
		rc-align以及ant design里tooltip组件的基石. 实现类似Sticker的功能
	layui（前身为layer） <url:http://www.layui.com/>
	uuid <url:https://www.npmjs.com/package/uuid>
		import uuid from 'uuid/v1' // 还有v4, v5，一般用v1即可
		直接 uuid() 即可生成
	ART 绘图 <url:https://github.com/sebmarkbage/art/>
	Vue.js <url:http://cn.vuejs.org/>
		60分钟快速入门 <url:http://www.cnblogs.com/rik28/p/6024425.html>
	直接操作dom样式：dom-css <url:https://www.npmjs.com/package/dom-css>
	图形库
		强大的图形库：gojs!! <url:http://gojs.net/latest/samples/dynamicPorts.html>
			太厉害了！感觉比d3还要厉害啊
			使用canvas来实现
			虽然好像不是开源，但好像给出了model!!!，是一个很好的参考
		JSNetworkX （astexplorer的作者从python库NetworkX上移植过来的） <url:https://github.com/fkling/JSNetworkX>
		gooflow流程设计插件, 好像也很有参考价值 <url:http://www.jq22.com/jquery-info16922>
	[theia] <url:https://github.com/theia-ide/theia>
	xterm.js web终端的解决方案 <url:https://github.com/sourcelair/xterm.js>
		vs code也使用了该库
	ascii表格
		string-length: 除了正确计算unicode长度之外，还忽略掉了ansi控制代码 <url:https://www.npmjs.com/package/string-length>
		string-width: 计算显示的长度，比如中文占2的长度，同样忽略掉ansi控制代码<url:https://github.com/sindresorhus/string-width>
		widest-line: 计算一个多行字符串里面最宽的一行的显示长度 <url:https://github.com/sindresorhus/widest-line>
			感觉不是很实用
	css-element-queries <url:https://www.npmjs.com/package/css-element-queries>
		里面有一个ResizeSensor，可以用来监听dom元素尺寸的变化
		但其有一定的侵入作用: 会将原来元素的position改为relative，并且还会注入一些辅助的元素
		因此对于在svg foreignObject里的html元素来说，可能会带来问题
	3D库 Three.js <url:https://threejs.org/>
		一些很酷炫的demo <url:http://christmasexperiments.com/experiments>
		react-three-render demo <url:http://toxicfork.github.io/react-three-renderer-example/#/webgl_draggable_cubes>
		react-three <url:https://github.com/Izzimach/react-three>
		The interactive example from react-three <url:http://izzimach.github.io/demos/react-three-interactive/index.html>
		react and three.js <url:https://tweedegolf.com/2016/02/16/react-threejs/>
	html编码、解码
		He（html entities） <url:https://www.npmjs.com/package/he>
			issue: encode一段中文会把所有东西都encode进去了
	模板 ejs <url:https://www.npmjs.com/package/ejs>
		流程<% %>
		转义<%= %>
		不转义<%- %>
		找到几个vim的插件，未体验 <url:https://github.com/nikvdp/ejs-syntax> <url:https://github.com/briancollins/vim-jst>
