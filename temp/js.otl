[javascript]
	语法基础
		[typeof]
			typeof NaN // "number"
			typeof null // "object"
			typeof undefined // "undefined"
			typeof true // "boolean"
			typeof new String('123') // "object"
		[===][==] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness>
			如果 a === b，则a==b
			NaN != NaN
			+true === 1
			true == 1
			true == "1"
			true != "true"
			-0 === +0
			null == undefined
			null !== undefined
			null === null
			undefined === undefined
			Infinity === Infinity
			要从设计者的用意来理解 == 的比较规则
				[ToNumber(A)] 即+A运算，转为数字. 因为boolean更接近number类型，所以遇到boolean的比较，会转成数字来比
				[ToPrimitive(A)] 对于object的类型，primitive会依次取toString，valueOf
		布尔类型
			falsy值: ''
			true值: '0'
		数值类型
			取小数点固定几位: toFixed(3) // 取小数点后3位，返回的是字符串
		[undefined]
			undefined === undefined
		单双引号互括用于规避引号转义
			这是很多语言的做法
		...操作符
			对象里展开：{ ...xxx } 如果xxx不是对象，直接忽略
				即：...undefined, ...null, ...123 都是合法的，但仅限于对象内，在其他场合的使用方法会不同
			数组中的应用
				const arr = [1, 2, 3, 4, 5]
				let [...a, b] = arr // 错误！
				let [a, ...b] = arr // 正确
				可以直接把字符串转为数组
					当然split方法也可以
			函数参数中的奇招: function group(o, [...by], {...opt}){...}
				这样很明了参数的意图，并且传入的参数非法时，也能至少保证by是一个空数组, opt是一个空对象，而不会报错
			坑：
				[...undefined]是非法的，{...undefined}却又是合法，这已经被坑了好多次了
		交换变量 [a, b] = [b, a] // es6以上
		连等陷阱 <url:./filets/js/syntax/equal.js>
		(,)陷阱 <url:./filets/js/syntax/parentheses.js>
		[toString()]
			js里通常不提接口，但很多地方使用了对象的toString()方法来生成用于显示的字符串信息，这里属于js里"接口"理念的一个轻淡地体现
		[valueOf()]
		声明、赋值、运算符
			声明多个变量
				let a, b = 1 // a为undefined, b为1
			连等赋值
				let a = b.c = {}
			解构赋值（...）
				支持特殊字符串构成的key，例: const {'&:first-child':xx, ...rest} = a
				支持key里为变量：const {[aaa]:a, [bbb]:b} = x
			解构组合
				{...1, ...null, ...undefined, ...true} -> {}
			幂运算 2 ** 3 // = 8
	[other of global]其他内建对象
		[binary] 二进制
			另起炉灶
				无视Node的Buffer标准，重新定义几个新概念
			[ArrayBuffer]
				底层buffer，不直接操作
					作为TypedArray和DataView的载体
			[TypedArray] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray>
				记代表: Int8Array, Uint8Array, Float64Array
				只支持big endian
				享受Array的其他操作，这也是另起炉灶的原因之一
			[DataView] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView>
				类似C里的struct的操作
				支持指定endian
				.setInt16(12, 42, [true])
				.getInt16(3, [true])
			[Blob] 与文件联接
				new Blob([字符串, buffer, 或者blob, ...], {type: "text/plain;charset=utf-8"})
				最简单的用法：new Blob(['aa'])
			[File] Blob的扩展
				还是Blob，多了一些文件属性
				通常由控件取得
					比如file input，文件拖入
			[FileReader]
				new FileReader()
				提供读File方法, 通过reader.result来取值
					readAsDataURL(blob)
					readAsText(blob)
					readAsArrayBuffer(blob)
					...
				提供事件（遵循dom模型）
					load
					progress
					...
		[timers]
			[setTimeout]
				clearTimeout可以真正撤消（不同于asio会触发回调）
			[setInterval]
				timer = 窗口.setInterval(fn, time); clearInterval(timer)
		Date
			UTC: 世界统一时间。GMT: 格林威治时间. 可以认为是UTC的一种表达方式. 在date对象里，toUTCString === toGMTString [deprecated]
			date对象, 由new Date(...)生成, 直接调Date()等价于(new Date()).toString()
			new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])
			一系列的get*, set*方法，查文档
			直接生成毫秒值：Date.now
			Date.parse, Date.UTC
			高级功能：见moment库
		[URL] <url:https://developer.mozilla.org/en-US/docs/Web/API/URL>
			url的类
				和location相似
			浏览器端的两个方法
				根据文件快速创建一个临时url
					URL.createObjectURL(blob)
				回收临时url
					URL.revokeObjectURL(url)
			资料
				base64形式: 'data:image/png;base64,xxxxxxx' // 似乎逗号后没有空格
	parseInt, parseFloat: 在新的标准中，它们将被收编入Number类方法里。Number.parseInt === global.parseInt
	事件循环: 任务队列、执行栈
		据说有多个任务队列？不深究了. 总之Promise的then是异步，但前于setTimeout和setImmediate
		而setImmediate和setTimeout在浏览器和node上行为不同
	[Object] Object对象的酷魔法
		[Object.defineProperty]
			Object.defineProperty(obj, 'aa', ...)
			configurable
				一次性门，一旦关上则不能再被打开
			enumerable
			value
			writable
			get
			set
		[Object.keys]
			不取原型链, enumerable only
			对应_.keys()
		[Object.is]
			Object.is(NaN, NaN) => true
			Object.is(+0, 0) => true
			Object.is(+0, -0) => false
			Object.is(0, -0) => false
			其余时候同 ===
		[for in]
			会取原型链，enumerable only
		[Object.getOwnPropertyNames] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames>
		[restriction] 限制
			[Object.isExtensible] [Object.preventExtensions]
			[Object.isSealed] [Object.seal]
			[Object.isFrozen] [Object.freeze]
		[prototype]
			[obj.hasOwnProperty]
			[obj.propertyIsEnumerable]
	Symbol
		解决标志变量、属性名全局唯一的问题
		Symbol()和 Symbol.for/Symbol.keyFor 并不共享
		需要通过Object.getOwnPropertySymbols才能枚举symbol属性. 或者通过反射Reflect.ownKeys
		Symbol.hasInstance
		Symbol.isConcatSpreadable
		Symbol.iterator
		Symbol.match: 只针对regxp是否能被startsWidth/endsWith
		Symbol.prototype
		Symbol.replace
		Symbol.search
		Symbol.species: 似乎只针对array.map的情况
		Symbol.split
		Symbol.toPrimitive: 便于快速转换类型, 比如 +x（转为number）
		Symbol.toStringTag
		Symbol.unscopables
			object1[Symbol.unscopables] = { property1: true };
			with (object1) { console.log(property1); } // 会报错
		Symbol.for()
		Symbol.keyFor()
		Symbol.prototype.toSource()
		Symbol.prototype.toString()
		Symbol.prototype.valueOf()
		Symbol.prototype[@@toPrimitive]
	[String]
		unicode问题
			在通常情况下，字母和中文字都作为一个字符（char）对待，对Unicode码点大于某个值的字符，js需要用两个长度来表示
			传统的方法（不能解决该问题）
				String.fromCharCode(num1[, num2...])
				str.charAt()，跟[]很像，但在一些边缘情况的行为略不同
				str.charCodeAt()
			新的方法
				String.fromCodePoint(num1[, num2...])
				str.codePointAt()
		template literal
			tagged template literal
				fn`some string here` 等价于 fn([ 'some string here' ])
				fn`this is a ${a} day ${b}` 等价于 fn([ 'this is a ', ' day ', '' ], a, b)
				如果不是tagged，`this is a ${a} day`将直接把a变量转成string
		str.length
		str.concat(string2[, string3, ..., stringN])
			和数组concat的用法类似，但建议直接用+运算符代替
		查找、替换
			正则语法糖: 参数不支持正则表达式，因此如果都传了正则，还需要这些语法糖干什么
				str.endsWith(searchString[, length]) 
				str.startsWith(searchString[, position])
				str.includes(searchString[, position])
			查找
				str.indexOf(s[, from])：from指定从哪里往后找
				str.lastIndexOf(s[, from])：from是指定从哪里往前找
					这里的from的负值行为不一样，如果为负，则相当于为0
				str.includes
			正则
				str.match(regexp)
					参数为正则表达式（如果传入的不是正则，将隐式转换）
					如果正则没有g，返回结果中str.match(regx)等价于regx.exec(str)
					如果有g，则返回一个所有匹配的数组
						一个纯数组，没有其他额外信息比如index
				str.search(regexp) 正则版的indexOf. 但没有第二个参数
				str.replace(regexp|substr, newSubstr|function)
					巧用replace可以用于从字符串中截取某个特定位置的子串 reg.replace(/<%\s*\.(.+?)\s*%>/, '$1')
					支持正则表达式，并支持选项，如/haha/g（当然也可以用字符串）
						很多高级用法，参见手册
					坑：如果不通过正则表达式指定/g，则默认只替换第一个找到的结果
					例：text.replace(/javascript/gi, "JavaScript")
					name = "Doe, John";
					name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1"); // John Doe
					如果要取整个串，好像是$&
					支持传入一个函数：
						text = text.replace(/<img src="res\/img\/biaoqing\/(.*?)\.bmp">/g, function (t)
						{
								t = t.slice(t.search(/\d+\.bmp/));
								t = t.slice(0, t.search(/\.bmp/));
								// 返回的字符串则表示要替换的新串
								return biaoqing_code[t];
						});
					如replace(/^[^\d.]*/, '')，代表什么含义？
		裁剪
			str.slice(begin[, end]) // to
				slice(0); // 相当于创建了字符串的副本
				slice(-2); // 从倒数第2个开始
				slice(1,3); // halfopen，即选1、2个，不包括第3个
				slice(0, -2) // 支持负数：去掉最后两个
			str.substr(start[, length]) // by
			str.substring(indexStart[, indexEnd]) // 很像slice. 一个重要的区别是 start和end支持交换
			str.trim()
			str.trimEnd(); str.trimRight();
			str.trimStart(); str.trimLeft();
			str.split([separator[, limit]])
				可以用正则
				'1232'.split() // ['1232']
				'1234'.split('') // ['1','2','3','4']
				'1234'.split('4') // ['123','']
				'22'.split('2') // ['', '', '']
		大小写
			str.toLowerCase()
			str.toUpperCase()
		画表格
			str.padEnd(targetLength [, padString])
			str.padStart(targetLength [, padString])
		str.repeat(count)
		String.raw`Hi\n${2+3}!` => Hi\n5，注\n就真的是'\n' + 'n'，而不是换行
		不常用
			str.localeCompare() 不常用，略
			str.normalize()
			str.toLocaleLowerCase()
			str.toLocaleUpperCase()
	Number
		==类==
		parseInt, parseFloat陷阱: 传入的参数是字符串. 
		==实例==
	[Array] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array>
		*表示改变原数组
		arr.length
		构造
			Array(3): 构造有三个元素的数组
			Array.from()
				Array.from(arrayLike[, mapFn[, thisArg]])
				Array.from(iterable)
			Array.of()
				跟new Array一个重要区别是：Array.of(7) => [7] 
		Array.isArray() 官方的判断是否为数组的方法，lodash也是调用它
		arr.concat(value1[, value2[, ...[, valueN]]])
		*arr.copyWithin(target[, start[, end]]): 类似c++里的move
			[1, 2, 3, 4, 5].copyWithin(-2, -3, -1); // [1, 2, 3, 3, 4]
		迭代
			arr.entries() 返回迭代器
				['a', 'b', 'c'] 迭代的内容是[0, 'a'], [1, 'b'], [2, 'c']
			arr.keys() 返回keys的迭代器（注：不是keys数组，似乎有点鸡肋）
		对标lodash: 但lodash的兼容性及容错性更强
			注：lodash不提供this参数）
			arr.some, arr.every, arr.filter
				arr.some(callback[, thisArg])
			arr.forEach（注：lodash有each和forEach，两者是alias关系）
			arr.map
			arr.reduce((a, c)=>new_a, init_value])：反向为reduceRight
				初始值可以缺省
			arr.reverse()
			arr.sort 和 _.sortBy 有所区别
		*splice(start[, deleteCount[, item1[, item2[, ...]]]]): 剪辑（字符串没有该方法）
			会改变原数组
			返回删除的子数组
			deleteCount缺省的话，会把后面的全删掉
		同字符串
			arr.includes
			arr.indexOf
			arr.lastIndexOf: 与数组不同！其from支持负，而数组如果from为负则相当于0
				[1,2,3,2].lastIndexOf(2,-2) // 1
				'1232'.lastIndexOf('2', -2) // -1
			arr.slice
		查找
			[arr.find]
				返回元素值
					arr.find(func[, thisArg])
			arr.findIndex(func[, thisArg]) 同find，但返回找到的元素index
		*栈和队列
			arr.push(element1[, ...[, elementN]])，返回push的数目
			arr.pop() 弹出最后一个元素，返回弹出的元素
			arr.unshift(element1[, ...[, elementN]]) 反向push
			arr.shift() 反向pop
		arr.join(sep = ',')
		arr.fill(value[, start[, end]]) // 填值
		提案中
			arr.flat(depth = 1)
			arr.flatMap(...) // 先map，再flattern 1级. 用于那些map函数会提升层级的场景
				[1, 2, 3, 4].flatMap(x => [x * 2]) => [2, 4, 6, 8]
	Math
		Math.min(1,2,3,4) / Math.max类似
		Math.hypot 用来求距离很方便: Math.hypot(3, 4) => 5
	函数
		函数的名字可以通过其name属性取到，但尽量不要依赖它。因为js压缩混淆之后，函数名会丢失
		函数的length: 即函数定义时的参数个数
			应该是确定参数的个数吧？对于(a, b, ...c)这种形式还未深究
		箭头函数技巧
			(([x])=>{ /* 当为对象，数组的解构形态时，外层 ( ) 不能省 */ console.log(x) })(['haha'])
			类里的箭头函数方法，是可以被完美继承的
		arguments
			似乎es6要将其相关特性废除（caller, callee等）
		自己约定
			纯函数用箭头函数，不纯函数使用function
	[class]
		[class declaration]
			getter和setter
				例：set value(val){this.value = val}
			es规范不支持多继承
				虽然可以人为实现，但值得思考是否必要
			杂
				私有属性、方法 #前缀: #a, #fun，好像现在babel还不支持
		[constructor function]
			[new] new的实质
				var obj  = {};  
				obj.__proto__ = Base.prototype;
				Base.call(obj);
			[inheritance]
				with __proto__
					Dog.prototype.__proto__ = Animal.prototype
				without __proto__
					方法就多种多样了
	/../ [RegExp] 正则表达式 <url:#r=regexp>
		正则表达式语法 <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions>
			\
			^, $
			*
			+
			?：{0,1}，又用来表示非贪婪模式，如a*?（可用于任意数量修饰符之后）
			.：除了\n，所以如果要匹配真正意义的任意字符，要用[^]，当然[\s\S]，[\d\D]等也可以
			(ｘ)：子匹配，子匹配是可以嵌套的. 放入寄存器的顺序是进栈的顺序，即'('的顺序（先根遍历）
			(?:ｘ)：匹配子模块但不放入$1-$9里
			ｘ(?=ｙ)：look ahead
			ｘ(?!ｙ)：negated look ahead
				现在也普遍支持look behind了
				console.log(/(?<=Jack|Tom)Sprat/.test('TomSprat')) // true
				console.log(/(?<=Jack|Tom)Sprat/.test('TSprat')) // false
			ｘ|ｙ
			{n}
			{n,}
			{n,m}
			[ｘｙｚ]
			[^ｘｙｚ]
			[\b]
			\b word boundary. 词语的边界
			\B
			\cｘ
			\d
			\D
			\f
			\n
			\r
			\s
			\S
			\t
			\v
			\w
			\W
			\n
			\0
			\xｈｈ
			\uｈｈｈｈ
			\u{ｈｈ}
		构造函数
			字面量表示法略
			new RegExp()同RegExp()，可以接收一个字符串或者一个对象
				注：RegExp(/a/) 跟 RegExp('/a/')不等价!
				RegExp('ab+c', 'i') => /ab+c/
				RegExp('\\w+') => /\w+/
		flags（后缀）
			i 忽略大小写
			g 全局匹配（多个匹配）
			m 多行模式。缺省^和$匹配整个字符串的首和尾，启用了m之后，^和$则用来表示行首和行尾
			u unicode模式: 比如/a.b/u 中的「.」可以匹配一个大的unicode字符，但如果不加/u的话，仍会把大unicode字符当两个字符看待，导致不匹配
			y sticky
				sticky其实隐含了g的行为，区别是其严格按lastIndex所在的位置来检查是否匹配（普通情形是从lastIndex开始往后找到匹配就行）
		匹配检测方法
			[状态机]: regx是以状态机的机制来进行匹配的，尤其是对于g
			regx.test()：最常用的检测方法。注：对于g flag状态机，test可以多次调用来'查找下一个'，直到找不到时，会返回false。然后循环此过程。因此可用来进行查找计数
			regx.exec()：test的详尽版：除了返回true和false之外，还返回详尽的结果。状态机机制与test完全一样
				返回结果, 是一个扩展的数组{ 
					[匹配的串，...匹配的子串（取决有没有加括号）], 
					index: 匹配的位置, 
					input: 被检测的串}
					chrome里还有一个groups:undefined，暂时不知何用。mdn里没有介绍，firefox里没有该字段
				不匹配则返回null
		寄存器: 只要发生成功的正则匹配，寄存器都会被刷新，如果匹配不成功，则寄存器的值不变
			RegExp.$1-$9：对应string.replace里的$1-$9. 取最后的9个. 它们未赋值状态下都是''
			RegExp.input（$_）：被测试的字符串
			RegExp.lastMatch（$&）：匹配的结果字符串（不是子匹配）
				其实命名里'last'修饰是多余的。这里所有寄存器隐含last的含义
			RegExp.lastParen（$+）：最后一个子匹配
				虽然它必然在$1-$9中，但你有时不知道是其中的哪一个
			RegExp.leftContext（$`）：匹配串前面的部分
			RegExp.rightContext（$'）：匹配串后面的部分
		regx.flags: 取flags，如'gi'，按字母顺序排列: /aa/mig.flgs => 'gim'
		regx.global, regx.ignorecase, regx.multiline, regx.sticky, regx.unicode: 对应几个flag
		regx.source：原始字符串，没有首尾两个//。如果用toString()方法的话，会包含//
		regx.lastIndex：可读可写。一开始只用于g；扩展用法见y
		另见 sring.match <url:#r=string.match>, string.replace <url:#r=string.replace>
		资料
			网上一个知识点速查 <url:http://www.jb51.net/article/43190.htm>
			网友整理常用正则表达式 <url:http://www.jb51.net/tools/regex.htm>
	Map
		const map = new Map([ ['name', '张三'], ['title', 'Author'] ]); // 或者new Map()
		map.size // 2
		map.has('name') // true
		map.delete(o) // 删除
		map.get('name') // "张三"
		map.has('title') // true
		map.get('title') // "Author"
	Set <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set>
		阮一峰的介绍 <url:http://es6.ruanyifeng.com/#docs/set-map>
		var set = new Set([1, 2, 3, 4, 4])
		let set2 = new Set() // 空集
		set.add(5)
		set.delete(3) 
		set.has(4) 
		set.clear()
		[...set] // 用set来进行数组去重
	WeakSet和WeakMap
		主要用于全局变量上的内存管理性能上的优化。并非编码上的优化
	[proxy] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy>
	[reflect] <url:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect>
		跟proxy配合使用，取默认行为
	模块化Modules: import/export
		语法理念：导出和导入的书写形式需要保持一致
			例：导入为
			import React, { Component } from 'react'
			导出则应为
			export default React
			export { Component }
		import单例性：多次import只执行一次
		无名导入side effect（缺省加载）
			import 'xxxx'
		导入所有 impot * as
			import * as user from './user.js'; // 随后用user.xx来访问具体导入的成员
			似乎有人建议用这种方式来代替 import R from 'ramda'的形式
		级联写法（从别处导入，再导出）
			export { foo, bar } from 'my_module'
			透传导出
				export * from './api_mock.js'
		import()函数: 好像babel还不支持
		导出的变量都是只读？
			在create-react-app这里是如此，但似乎变量里面的属性，可写
		不支持的写法
			export {...xxx} // 这是动态解构，而es6的模块机制是静态的
			import { a : {b, c} } from ... // 不支持
			export aaa // 可以export const aaa = xxx，但export aaa则是非法语句，应写成export {aaa}
	函数式编程 <?utl:id=js_fp?>
		纯函数: 简单理解为没有状态的函数
			那等同于输出完全被输入决定吗？那如果一个随机数函数呢？感觉这是个灰色地带
		柯里化（Currying）: 部分绑定的完美形态，<url:#r=lodash_curry>
		Hindley-Milner风格的函数类型签名（在注释里标明js函数的类型）
			类似箭头函数的风格，仅供参考
			例：//  replace :: Regex -> String -> String -> String
		知乎用户vczh对其的描述 <url:https://www.zhihu.com/people/excited-vczh/answers>
			函数式编程在使用的时候的特点就是，你已经再也不知道数据是从哪里来了，每一个函数都是为了用小函数组织成更大的函数，函数的参数也是函数，函数返回的也是函数，最后得到一个超级牛逼的函数，就等着别人用他来写一个main函数把数据灌进去了。 
			知乎讨论 <url:https://www.zhihu.com/question/28292740/answer/40336090>
	JSON
		parse
		stringify
			JSON.stringify(p.bp, null, '  ') // 这样可带有缩进, 缺省形式JSON.stringify(xx)得到的结果是没有缩进的，应该是紧凑的一个单行json
	Arson json的升级版 <url:https://github.com/benjamn/arson>
		支持更变态的数据结构，比如环状引用等
		可以解构导入：import {encode, decode} from 'arson'
	Promise对象
		世界观（promise对象的哲学理念）
			promise世界观是async诞生的基石
			故事
				在之前的js中，异步操作（调用）必要指定回调函数，并且构造时就要指定好，否则就再无机会
				而为何不能晚一步再指定回调呢？这就是promise
				promise对象：对所有的异步操作（广义地，还可以把同步操作也包括进来）进行了抽象，它一旦产生，异步任务便开始启动。但此时它并不打算在任务完成之后，做点什么
				直到你来告诉他，通过其then方法。例: promise.then( x => y )，这时它便知道任务完成之后要做的事情
				如果之后要做的事情，也是promise的性质，便可以写成级联的形式 .then(x => y).then(y => z)...
			promise的对象是数据
				任何形式的promise，不管是同步还是异步，都可以抽象为最终会得到某些数据，比如是一个用户id，为了便于概念提炼，我们可以称之为一个"用户id的promise"
			promise只能返回一个值（只返回一个变量）
				当然如果es委员会愿意，js可以像go一样，令promise也可返回多个值（到了async函数层面需要支持函数也返回多个值），但考量了之后似乎没有这个必要
				限制为一个值也许更利于代码的组织和维护
		初探 <url:./filets/promise.html>
		resolve的接管
			如果resolve的参数是一个promise，则原promise的then将连接新promise
			这个理念常用于promise对象的设计中（比如将一些回调形式的库promise化）, 而在promise的使用中不太需要用到
		then 方法
			伪代码：then( x => y ) -> z 注：这里x为new Promise时传入给resolve的变量（y展开则为函数体, 其返回值为y）
				完整版是then( x => y [, e => ]), 即还可以传一个reject
			then总会又返回一个promise对象，因此可以继续对该promise进行级联处理
		catch 方法
			其实是 then(null, reject)的别名
			catch的返回值与then的返回值性质完全一样（即可以进行级联，接管等）
			如果catch里没有解决问题，应当throw出去，以交由外层的catch来处理
			注：使用nodejs bluebird里的catch能捕获所有异常，即在promise链最后接一个catch，前面的普通js异常都能捕获，实在是太强大！不知道这是否为Promise的规范
			bluebird实现的catch还能filter <url:http://bluebirdjs.com/docs/api/catch.html>
		Promise.all 全部都要完成
			例：Promise.all([p1, p2, ...]).then([f1, f2, ...]=>{})
		Promise.race 取最快完成的那个
			例：Promise.race([p1, p2, ...]).then(最快那个=>{})
		Promise.resolve/Promise.reject 快速就地构建一个 promise 对象
		阮一峰在es6里的介绍 <url:http://es6.ruanyifeng.com/#docs/promise>
		网友讨论如何加超时 <url:https://github.com/matthew-andrews/isomorphic-fetch/issues/48>
	[decorator] 装饰器、修饰器 <url:http://es6.ruanyifeng.com/#docs/decorator>
		提案 <url:https://tc39.github.io/proposal-decorators/#sec-syntax>
		示例: <url:./filets/js/decorator/01.js>
		自己粗略实现的一个autobind <url:./filets/js/decorator/02_autobind_simple_implemetation.js>
			问题：直接按一个包装函数的形式写的，而大概看了下官方的源码，没有返回一个类啊。这是什么操作？得好好研究一下
	iterator迭代器
		世界观：对于forof循环，以及类似[...xx]这样的遍历操作，需要一个统一的迭代器接口来适配
		迭代器接口：{ next() = { value: ..., done: true/false } }
			只要满足如上述规范能不停执行next()的对象，都可称之为迭代器（鸭子类型）
		给对象部署迭代器
			{ [Symbol.iterator]: ()=> 迭代器对象 }
			示例：
				let obj = {
					...
					// 返回一个{ next() }的对象
					[Symbol.iterator]() { return { next() { ...  return { value: .., done: ... } } } } }
	[Generator] 函数（状态机、生成器）
		生成器调用之后，返回迭代器。其具有一些特殊属性
			自迭代: 它自己的迭代器又是它自己（故称为自迭代器）
				一般的迭代器用法通常是部署到主体上，使得主体可以被迭代解构（...或者forof等），而generator生成的迭代器自己就是自己的主体
				function* gen(){ // some code }
				var g = gen()
				g[Symbol.iterator]() === g
			作为async函数的基石
			throw() （未深究）
			return() 直接终结迭代。暂不深究
				据说如果有try catch finally的话，也需要等finally执行完才终止
		function *foo() {
			yield 1
			yield 2
			return 3 // forof循环体不会走到return的值，这符合经典的迭代器半开闭模型 }
		yield* 令生成器可拼装（composable）
			yield* 跟的是迭代体，而generator返回的对象即是迭代器又是迭代体，因此可作为yield*的对象实现generator的组装
			function* gen(){
				yield* ["a", "b", "c"] } // 这时gen()便得到了另一个同样可以遍历数组的迭代器
		示例
			forof
				function *foo() {
					yield 1
					yield 2
					return 3 // forof循环体不会走到return的值，这符合经典的迭代器半开闭模型 }
				for (let v of foo()) { console.log(v) } // 不输出3
			co原理（async函数前身）
				定义一个generator
				在内部逐一yield异步任务的promise
					之所以yield的是promise，是因为promise是js中对异步调用最合适的抽象
				在外部，由一个统一的执行器（比如经典的co）来执行该generator，执行器返回promise
					执行器做的主要事情就是在yield出来的promise的then里，调用状态机的next，这样便把一系列异步任务串了起来，最终完成整个流程
	async函数
		本质上是co模式的语法糖, 但其令语义更直观清晰 <url:./filets/co.js>
		基本语法：const xx = await SomePromise
		返回promise
		使用场合跟普通函数几乎相同
			可自调用
			可作为对象方法
			...
		异常处理
			坑：async函数要想能正确地处理异常，需要所有的异步调用都显式地加上async/await，否则隐式的返回promise的代码里的异常将无法被catch
				如果这个promise也被显式地await的话，可以避免这个问题吗？
	[fetch]
		参考（不能作文档）<url:https://fetch.spec.whatwg.org>
		示例 <url:./filets/js/fetch/>
			有传header的示例
			上传文件的示例
			下载进度
		非常好的一篇讲解 <url:http://louiszhai.github.io/2016/11/02/fetch/>
		返回promise of res:
			res.ok: bool，判断http请求是否成功
			获取http头（headers）
				res.headers.has('content-type'), res.headers.get('transfer-encoding')，这里与koa不同，只能通过方法获取，不能通过对象的属性来得到
		传cookie: (url, {credentials: 'include', ...})
			include: 始终传cookie
			same-origin: 不跨域才传
			omit: 缺省。始终不传
		异常
			在同一条then链上的throw是可以被后面的catch捕获的，但内部如果又另起一个promise的链，则外部promise的catch无法捕获其异常，例：
				: xxx.then(
				: 	throw xx
				: 	yyy.then(
				: 		throw yy
				: 	)
				: ).catch(
				: 	这里可以捕获到xx，而不能捕获yy
				: )
		中断: 使用AbortController和AbortSignal的方式，可以将fetch abort. 要非常新的Chrome才支持
		资料
			这个Api很fetching <url:https://www.w3ctech.com/topic/854>
			传统 Ajax 已死，Fetch 永生 <url:https://github.com/camsong/blog/issues/2>
			mdn <url:https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch>
			可以跨域（需要服务端支持），比如试试这个链接: <url:https://api.github.com/gists>
		坑
			在微软edge浏览器里，不允许将某个header设为空，否则会抛异常
	测试
		Jest <?utl:id=jest?> <url:https://facebook.github.io/jest/> <url:https://facebook.github.io/jest/docs/api.html>
			facebook官方推荐的很强大的测试库，可以测试React和React Native
				据说已经超过mocha等框架成为js测试的最佳选择
				已整合进create-react-app以及react native的cli里
				通过快照来测试react组件，非常方便!
			xx.test.js为测试代码文件. 示例 <url:https://facebook.github.io/jest/docs/getting-started.html#content>
				据说create-react-app还支持识别__tests__/下的文件作为测试代码，但个人暂时不使用该方式
			配置 <url:https://facebook.github.io/jest/docs/getting-started.html>
				create-react-app自动集成jest，不用配置
				如果是node的项目，按照官方文档下载对应的包，普通使用场景不需要任何jest的配置即可正常使用
					babel的配置还是需要的
					自动watch的功能，可借鉴create-react-app项目eject之后的script/test.js，搬到当前项目中来即可
			可以用describe来对用例进行分组 <url:https://facebook.github.io/jest/docs/api.html>
			测试react
				用jest自带的snapshot详见 <url:./filets/jest_react/Link.test.js>
					官网示例 <url:https://facebook.github.io/jest/docs/tutorial-react.html#content>
				Enzyme <url:http://airbnb.io/enzyme/index.html>
					jest的snapshot机制只能检查简单的渲染，对于复杂的ui交互则可以使用Enzyme
			测试异步代码 <url:https://facebook.github.io/jest/docs/asynchronous.html>
				官网文档非常直观，正如你想象中简单！
			mock <url:./filets/jest_async_mock/user.test.js>
				mock机制世界观
					放置mock代码
						在__mocks__目录里放置对应的mock模块。mock模块没有特殊的依赖，保证与目标的导出接口完全一致即可
					指定哪些在mock
						在测试用例（测试代码）里jest.mock('./xx.js')
							据说默认情况下，node的原生的模块只要有mock，不需要指定就会自动mock?
				mock函数（mock工具） <url:https://facebook.github.io/jest/docs/mock-functions.html#content>
					mock的模块只是角色是mock而已，和真正的实现在本质上是没有区别的。但为了更好地测试和统计，jest提供了一些工具来辅助mock模块的实现
					详见代码
			npm t ...或jest ...，即可启动测试
				例：npm t -- -t="haha" 对应 jest -t="haha"
				不建议在git-bash上运行
			命令行参数
				arg（直接参数，非选项） 匹配文件，regex
				-u --updateSnapshot 更新react组件的快照
				-t --testNamePattern=<regex> 匹配名字
					名字指的是每个测试用例的描述字符串，如test('这就是名字', ...)
			坑
				jest里不能用 x=>{}这样的写法，好像test这一行不能写，里面还是可以的
	[webpack] <url:https://webpack.js.org>
		[concepts]
			Entry
			Output
			loaders
			Plugins <url:https://webpack.js.org/concepts/>
		Loaders
			css-loader: css文件的原始loader，通常需要配合其他loader使用（比如style-loader）
			style-loader: 将css loader得到的对象加到DOM里作为一个<script>标签
		[plugins]
			html-webpack-plugin
			clean-webpack-plugin 构建前清空指定某些目录 <url:https://www.npmjs.com/package/clean-webpack-plugin>
				create react app也会清空目录，但是在build.js里调用fs-extra里的函数来清空的。因此没有用到该模块
		webpack命令
			-w watch模式
		[config]
			externals 见webx里的示例
		坑: webpack dev server的host是有限制的。不能随便用域名
			通过看其源码，改其中一个选项即可以放开该限制
		资源
			中文书 <url:http://webpack.wuhaolin.cn/>
			合集 <url:https://github.com/poetries/mywiki/wiki/webpack>
	Babel <url:https://babeljs.io/>
		阮一峰教程 <url:http://www.ruanyifeng.com/blog/2016/01/babel.html>
		插件（plugin、preset）常用的有latest, state-1，详见文档
			Remove console transform 删掉所有的console.* <url:https://babeljs.io/docs/plugins/transform-remove-console/>
			babel-plugin-module-resolver 修改module的路径 <url:https://github.com/tleunen/babel-plugin-module-resolver>
				可以用来模拟一个全局module的机制，适用于快速编写一些编译、部署、测试脚本。不适合生产环境的程序
				示例："plugins": [ [ "module-resolver", { "root": [ "C:/Users/guanghui/react_playground/node_modules" ] } ] ]
					结合官网查看完整例子
		配置示例
			"babel": {
				"presets": [
					"latest",
					"stage-1", "react"
				],
				"plugins": []
			}
			这些presets都要单独安装，比如react对应的npm包为babel-preset-react
		process对象
			似乎会在用于web前端的js模块内注入一个process对象（就像在nodejs里一样访问），其特征是：process.browser = true，可用来区分当前代码是执行在node环境还是浏览器环境
			用于编写同构化（即浏览器和node通用）的代码
		Babel-Polyfill
			通常是补上一些prototype，可以一定程度地解决浏览器兼容性的问题
		坑
			export const json = fetch_fn => async (...para) => { // 猜测是，...para直接透传的话就会出bug？，还是跟async有关
				// eslint-disable-next-line
				para; // 这是babel的bug，经试验，若省略这一行的话，会出现诡异的错误
				const res = await fetch_fn(...para)
				return res.json() }
			[...null, 1, 2] 会报错，而"..."用在对象中，则是不会抛异常的
	js算法
		实现任意数组的'乘': ['a','b','c'],['d','e'] => ["ad", "ae", "bd", "be", "cd", "ce"] <url:./filets/js/algorithm/array_product.js>
	坑
		闭包前面加分号！
			比如写下面的函数，如果前面的分号省略，会当成 a = b(function...) 来解析！
				: a = b
				: ;(function(){
				: 	console.log("haha")
				: })()
		promise结果的作用域
			使用promise的常用套路：
			xx.then(res => {...}).then(res => {...}) 根据代码习惯，会重复res变量名，但这个时候要非常小心注意不同的then里面的res含义不一样！
				曾经就是忽略了这一点，逻辑短路引起BUG
	奇技淫巧
		~~x 将其取整
		base64解码: b = new Buffer(a, 'base64') // 但这个方法已经被node官方废弃，最新版改为Buffer.from(a, 'base64')
			注：解出来是Buffer，而不是string
		arrayBuffer转Buffer: b = new Buffer(new Uint8Array(a))
		取Buffer里的字节的整数形式（字节转整数）: const num = buf[0] & 0xff; // 取自parse gp5的源代码
		高阶函数的"阶"的一个经典应用：计数生成器。计数器处在哪一阶，将决定其计数空间
		Console的高级用法
			node控制台版：console.table <url:https://www.npmjs.com/package/console.table>
			你真的了解 console 吗 <url:https://segmentfault.com/a/1190000000481884>
				涵盖了以下内容：
				console.assert
				console.count: 统计执行的次数
				console.group: 日志折叠
					可以嵌套
				console.table: 打印表格
				console.profile: 性能分析
				console.time: 运行计时
				console.trace: 打印函数的调用堆栈
			console.log和console.dir的微妙区别: <url:http://blog.csdn.net/manyangyangya/article/details/44859685>
			mdn console.table <url:https://developer.mozilla.org/en-US/docs/Web/API/Console/table>
			前端不为人知的一面--前端冷知识集锦 <url:http://www.cnblogs.com/Wayou/p/things_you_dont_know_about_frontend.html>
			Chrome 控制台新玩法-console显示图片以及为文字加样式 <url:http://www.cnblogs.com/Wayou/p/chrome_dev_tool_style_console.html>
			Colors in JavaScript console <url:http://stackoverflow.com/questions/7505623/colors-in-javascript-console>
		获取一个函数各参数的名字！ <url:https://davidwalsh.name/javascript-arguments>
			感觉似乎在做一些依赖注入的时候很有用，但由于babel的不确定性，可能会带来很多隐患，不建议使用
		字符串转数字 +"123"
	资料
		一次围绕setTimeout展开的面试（包含了promise的一些机制）<url:https://zhuanlan.zhihu.com/p/25407758>
		array-like objects（类数组对象）: arguments, dom里的东西
		browserify-as-a-service <url:https://wzrd.in/>
[awesome js] 第三方库
	[lodash] <url:http://underscorejs.org/> <url:https://lodash.com/docs>
		Lang
			_.isArray
			_.isFunction(value)
			_.isObject
				数组也是object: _.isObject([1, 2, 3]) // true
				isObject(null) // false
			_.cloneDeep 是可以处理环形数据结构
		数字、数值
			_.isEqual(a, b)
			_.clamp(number, [lower], upper)
				_.clamp(-10, -5, 5); // => -5 _.clamp(10, -5, 5); // => 5
		数组
			_.without 删除元素（返回新数组，使用简单的相等比较）
			_.pull类似without，区别在于其修改原数组
			_.remove 修改原数组，传入一个函数作为删除条件（跟_.filter类似吗）
			_.flatten _.flattenDeep _.flattenDepth 扁平化
			_.union 求并集
				除了合并，还有去重的功能
				_.union([3,2,1,1], [1,2,5])
				[3, 2, 1, 5]
				会保持元素出场的顺序
			_.findIndex, _.findLastIndex 类似find，但返回的是index
				_.findIndex(array, [predicate=_.identity], [fromIndex=0])
			_.indexOf 则是findIndex的简单版
			去杂
				_.compact, 清洗去掉false（falsy, falsey）的元素: false, null, 0, "", undefined, NaN
			截取
				_.head、_.first 取第一个元素（原数组元素级别）
				_.tail 去掉第一个元素（与原数组同级）
				_.initial 去掉最后一个元素（与原数组同级）
					如果只有一个元素，则该元素会作为"最后一个元素"（_.last）而被去掉，返回空数组，即_.initial([1]) => []
					可以接受非法输入，不符合逻辑的输入，均返回[]: 很利于编写高容错性代码
				_.last 取最后一个元素（原数组元素级别）
		对象
			_.get 对象取值，任意深度，支持缺省，省下处理抛异常的麻烦
				var object = { 'a': [{ 'b': { 'c': 3 } }] };
				_.get(object, 'a[0].b.c'); // => 3
				_.get(object, ['a', '0', 'b', 'c']); // => 3
				_.get(object, 'a.b.c', 'default'); // => 'default'
			_.set 对象设值，与_.get对应（会修改原对象）
				_.set(object, 'a[0].b.c', 4)
				_.set(object, ['a', 'b', 'c'], 4)
				对于不期望修改原对象的情况，可以用assign、defaults等方法
				注意：
					如果object不是一个对象，修改无效，直接原值返回
			_.unset 删除属性，会修改原对象。容错性强
				只支持删除一个路径
				_.unset(object, ['a', '0', 'b', 'c'])
				_.unset(object, 'a.0.b.c')
			_.at: _.get的批量版（取一系列的值，返回数组），这样好像就不支持缺省值了吧？
				var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
				_.at(object, ['a[0].b.c', 'a[1]']); // => [3, 4]
			_.keys: 取对象的属性列表
				该方法取不到方法列表，要实现这一点可参考自己封装的uniquer.js里的代码
			_.keysIn
				对应for in
			_.assign、_.assignIn, _.extend, _.merge, _.mergeWith系列
				_.assignIn（别名_.extend）的区别好像是其只考虑own and inherited source properties
				_.merge 深度拷贝（递归），会改变原对象，但不会修改参数
					能处理环路的数据结构！
					坑：
						通常用merge是用于的场景，但对于数组是不能实现覆盖的，因此使用时要特别注意
						let a = {a:[1, 2]}
						let b = {a:[2]}
						_.merge(a, b) // => {a:[2,2]}
				注：以上函数都修改原对象
			_.defaults, _.defaultsDeep
				与assign同为对象叠加的方法，但其逻辑是：仅当目前没有对应值时，才选择覆盖
				处理react的props时，不能正常工作，需要wash
				注：会修改原对象
			_.pick、_.pickBy 选出部分属性
				_.pick(object, ['a', 'c'])
				_.pick(object, 'a', 'c')
				pickBy(obj, (val, key) => bool )
				注：对于没有的属性，将会忽略（而不是pick出一个undefined值来）
			_.omit 去掉部分属性
				_.omit(object, ['a', 'c'])
				_.omit(object, 'a', 'c') 
			_.omitBy
			_.keys 返回数组
			_.mapKeys, _.mapValues 给keys或者values变换
				可以用于数组，可将数组转为对象
				_.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) { return key + value; }) // => { 'a1': 1, 'b2': 2 }
					注：mapKeys无法减少项目的个数
				var users = { 'fred':    { 'user': 'fred',    'age': 40 }, 'pebbles': { 'user': 'pebbles', 'age': 1 } }; 
				_.mapValues(users, function(o) { return o.age; }); // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
				_.mapValues(users, 'age'); // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
			_.has / _.hasIn 判断是否有某个属性（支持深度路径）
				hasIn检查祖先
				如_.has(object, 'a.b')
		集合（对象、数组都适用）
			_.includes 是否有某个元素[废弃underscore里的_.contains]
				数组和对象都适用（对象只检查key，不查value），还可用于字符串
			_.each（_.forEach）
			_.isEmpty. 对于{}和[]都返回true
			lodash里没有all和any，只有some和every
			_.some 返回bool（underscore里有别名 _.any）
				_.some([null, 0, 'yes', false], Boolean); // => true
				对于空集，_.some返回false
			_.every 与some相对（underscore里好像有别名，_.all）
				「坑」「注」：为了与some的逻辑相对称，_.every(空集合)为true！！
			_.groupBy （与自己的group的思路有一些交集，但定位不完全一样）
				_.groupBy([6.1, 4.2, 6.3], Math.floor);
				// => { '4': [4.2], '6': [6.1, 6.3] }
				// The `_.property` iteratee shorthand.
				_.groupBy(['one', 'two', 'three'], 'length');
				// => { '3': ['one', 'two'], '5': ['three'] }
			_.filter 筛选（有点类似sql的select）
				可以操作对象，但返回的结果一定是数组（类似_.map的机制）
				注：哪怕是筛选出来之后只有一个结果，仍然是返回数组，这跟sql的select一样!
				如果要返回对象，可以使用pick、pickBy
				: var users = [
				: 	{ 'user': 'barney', 'age': 36, 'active': true },
				: 	{ 'user': 'fred',   'age': 40, 'active': false }
				: ];
				:
				:	支持一些快捷方法
				: _.filter(users, function(o) { return !o.active; });
				: // => objects for ['fred']
				:
				: // The `_.matches` iteratee shorthand.
				: _.filter(users, { 'age': 36, 'active': true });
				: // => objects for ['barney']
				:
				: // The `_.matchesProperty` iteratee shorthand.
				: _.filter(users, ['active', false]);
				: // => objects for ['fred']
				:
				: // The `_.property` iteratee shorthand.
				: _.filter(users, 'active');
				: // => objects for ['barney']
			_.find 类似filter，但只找第一个
			_.findLast 类似find，但从后开始找
			[_.map]
				缺省调用，如：_.map(a)返回a的克隆
				lodash的map和数组原生的map相比，其容错性更强，还能兼容arraylike
				非对象，返回[]
			随机取一个 _.sample
				_.sample({a:1, b:2}) // 得到1或者2
			随机取指定个 _.sampleSize
			[废弃_.pluck] 用 _.map代替
				var objects = [{ 'a': 1 }, { 'a': 2 }]
				_.map(objects, 'a'); // → [1, 2]
		函数
			_.curry <?utl:id=lodash_curry?> 非常强大的柯里化！支持直接拿 _ 对象来作占位符！
				它的神奇效果实在是太令人兴奋了! 相见恨晚的感觉.  _ 终于亲自派上了用场! 
				var abc = function(a, b, c) { return [a, b, c]; };
				var curried = _.curry(abc);
				curried(1)(2)(3);
				// => [1, 2, 3]
				curried(1, 2)(3);
				// => [1, 2, 3]
				curried(1, 2, 3);
				// => [1, 2, 3]
				// Curried with placeholders.
				curried(1)(_, 3)(2);
				// => [1, 2, 3]
				注：一个参数被传了undefined和"该参数没传"等价
				因此，curried() === curried，进而curried()()()...() === curried，只有被传入不是undefined的参数之后，函数才会被降阶
				这里和天然的高阶函数的行为不一致：柯里化后的函数用法更灵活强大，同时也带来了这些坑
			据说 lodash/fp 模块还提供了更强大的函数式编程的工具 <url:https://github.com/lodash/lodash/wiki/FP-Guide>
				但好像fp里的方法在主模块（即_）里也有，比如fp.compose等同于_.flow（没有_.compose）
			_.flow, _.flowRight
			_.memoize（具有cache的函数）
				_.memoize(func, [resolver])
			_.debounce, _.throttle
				debounce像友善地等电梯（如果一直有人来，电梯可能一直走不了），throttle像班车（固定时间一班，到点即走不等人）。另外可以参考rxjs
		字符串
			_.trim, _.trimEnd, _.trimStart
				_.trim('  abc  '); // => 'abc'
			_.camelCase
			_.capitalize('FRED'); // 转成首字母大写
				// => 'Fred'
		Util: 一些函数生成器，通常用作map等函数的functor
			_.property
			_.identity
	[ramda] <?utl:id=ramda?> <url:http://ramdajs.com/docs/>
		还有一个附加的扩展包：Ramda Adjunct <url:https://github.com/char0n/ramda-adjunct>
		ramda也有占位符R.__
		阮一峰强烈推荐！支持在线测试: 首页 -> try ramda
		有一个自动得到ramda解决方案的库（ramda解题机器人） <url:https://github.com/bahmutov/rambo>
			const solution = solve([1, 2, 3, 4], [5, 6, 7, 8])
			console.log(solution.name) // "R.map(R.add(4))" 可以把解法给试出来！！！通过穷举法！
		cookbook 用实例来讲解使用ramda进行函数式编程的技巧 <url:https://github.com/ramda/ramda/wiki/Cookbook>
		R.curry 与lodash的curry类似
		R.curryN 类似curry，用于curry化参数不确定的函数
		R.map
			与lodash的区别:
			_.map({a:1, b:2}, v=>v+1) // [ 2, 3 ]
			R.map(v=>v+1, {a:1, b:2}) // { a: 2, b: 3 }
			对于非对象，得到[undefined]
			注：函数只能接收一个参数！！不能接收(key, value)
		intersperse 给数组元素间插一个分隔元素
			R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
		filter, reject: 类似lodash对应的功能, 但结果会保留原来的对象或者数组形式，但只能访问value
		R.pick, R.omit: 仅针对对象，因此可以访问到key和value
			跟lodash有点类似，但序列只支持用数组表示
		transduce, into <url:./filets/ramda_transduce_into.js>
		groupBy (fn, arr)=>{res1: [...], res2: [...], ...}
		reduceBy 为 groupBy的一般化，可自定义reduce算法
		groupWith 将数组按一定规则切块
		converge 聚焦 <url:./filets/ramda_converge.js>
		--- 函数式 ---
		compose, pipe: 由于其特殊使用场景，其结果不会柯里化
			注：真正理解了ramda之后，才真正理解ramda.compose的精髓！一般不会有使用pipe的场景
		tap 分线器（用于类似接入测量仪、电流表等的功能，不影响原来的数据流动，常用于打日志，或者是数据分流（像shell里的Tee命令））
			var sayX = x => console.log('x is ' + x); // 定义一个日志函数
			R.tap(sayX, 100); //接入日志函数，原来的数据原封不到，区别只是多打出了日志：logs 'x is 100'
		R.flip 将函数的前两个参数替换
	[rxjs] "lodash for events" <url:http://reactivex.io/rxjs/>
		rx支持多语言，其大主页: <url:http://reactivex.io/>
			在v6没完善之前，旧版的文档还得查 <url:http://reactivex.io/rxjs/manual>
		v6的划时代意义: 更纯，方能发挥函数式的威力
		[fromEvent]
			const clicks = fromEvent(document, 'click')
		[fromEventPattern] 根据提供addHandler/removeHandler来构建obserable
		[operators] rxjs
			[map]
			[flatMap] 先map->observable再flat
			[pairwise] 每人拉上其后面的一位 <url:https://rxjs-dev.firebaseapp.com/api/operators/pairwise>
		资源
			教程 <url:https://www.learnrxjs.io>
			旧版笔记
				Observable: 通常称为"源"
					「官方的test代码是一个非常形象的说明文档」
						以debounceTime为例 <url:http://reactivex.io/rxjs/test-file/spec-js/operators/debounceTime-spec.js.html#lineNumber5>
						具体符号的定义还未深究
					do: debug神器
					delay: 所有事件延迟指定时间
					reduce: 类似于array的reduce. <url:http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-reduce>
						记忆方法，所谓reduce，一定是要把东西'减少'，才能叫reduce!
						reduce((累积值, 当前值)=>新的累积值)
					scan: 类似reduce（参数完全同），但将每次累积的值emit出来 <url:http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-scan>
					mergeScan: 类似scan，区别为参数是一个observable的变换, 先scan再merge
					filter: 过滤。类似lodash的filter
						partition: 类似filter，但把剩下的那部分也拿来有用
					distinct: 去重（全局去重）
						distinctUntilChanged 局部去重
					partition: 同filter，但返回两个结果：合格的和不合格的都返回
					bufferToggle: 类似水龙头的一开，一关的一杯一杯装水动作
					window / windowToggle : 类似buffer，但拆成多路流，而不是数组
					startWith 在前面插入一个值
					多路合并
						switch: 新路直接覆盖旧路
						exhaust
					限流
						debounce: 类似等电梯案例，特点是如果陆续来人，电梯有可能永远没有机会走
						debounceTime: 直接传入时间间隔参数来debounce（原始debounce方法需要传一个流）
						throttleTime
						audit / auditTime: 跟throttle类似，暂不深究
						sample / sampleTime
				mumuzhenzhen的专栏教程 <url:https://segmentfault.com/a/1190000004293922>
					翻译自 The introduction to Reactive Programming you've been missing <url:https://gist.github.com/staltz/868e7e9bc2a7b8c1f754>
					文末系统推荐的文章似乎也不错
				汇智网的教程 <url:http://cw.hubwiz.com/card/c/569d92e3acf9a45a69b05154/1/1/3/>
				与react结合
					手写代码时，要特别注意避免发生事件重复订阅的情况，尤其是与ref结合使用时，因为react的ref经常会允许多次调用
					用redux的风格来将rxjs应用到react上
						Use RxJS with React, 这是一个很厉害的思想 <url:https://michalzalecki.com/use-rxjs-with-react/>
						Use RxJS with React <url:http://slides.com/michalzalecki/use-rxjs-with-react>
					rxjs-react-component 将react的事件转成observable的形式 <url:https://www.npmjs.com/package/rxjs-react-component>
						谨慎使用! 感觉使用的人不多
				旧版安装事项：官方的安装说明不适用于react, 直接npm i rxjs，而非官方文档上的npm i rxjs-es!!
					rxjs-es在create-react-app上不能编译
				示例
					who to follow demo <url:./filets/rxjs/who_to_follow>
	jscodeshift js代码批量自动修改神器！<url:https://github.com/facebook/jscodeshift>
		网上教程 <url:https://www.toptal.com/javascript/write-code-to-rewrite-your-code>
		另一个网上的示例 <url:https://glebbahmutov.com/blog/jscodeshift-example/>
		一个改注释的例子 <url:http://astexplorer.net/#/gist/8c7d9f81226bbbdee5d9c7a2468ddaa0/c3d93b44e2bf90e0ff2553ec1c8d85dd2daf807e>
		自定义逻辑完成代码的自动修改. 主页有大量的示例供参考，实在是太赞了！
		其是对recast的一个包装，recast就是一个用来批量修改js代码的库 <url:https://github.com/benjamn/recast>
		作者对其背景的讲解 <url:https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb>
	esnextbin 一个直接在浏览器端做前端项目的库 <url:https://github.com/voronianski/esnextbin>
	Flow <url:https://flow.org/>
	[mathjs] 处理数学的js库 <url:http://mathjs.org/docs/getting_started.html>
		[fraction]
			math.fraction('1/3')   // Fraction, 1/3
			math.fraction(2, 3)    // Fraction, 2/3
			math.fraction('0.(3)') // Fraction, 1/3
	astexplorer 一个强大的语法树解析库 <url:http://astexplorer.net/>
		支持多种语言的语法树的解析
		源码 <url:https://github.com/fkling/JSNetworkX> 
	PACE.js 页面loading效果的解决方案（页面加载）<url:http://github.hubspot.com/pace/>
	[D3] <url:https://d3js.org/>
		世界观：d3是一个很庞大的体系，但它并不是一个庞大的专制性的框架，而是被拆分成了许多个工具，允许你在任何框架中使用
			d3并没有彻底拥抱npm以及es6的模式，因此其官网的教程还是传统的js引入的方法（像传统的jquery全家桶）
			但由于它的各子模块还是放到了npm，给已经转入es6的用户带来了极大的便利
			以下笔记按npm的模块进行整理，基本上不影响传统风格示例代码的学习
		最近版本的在线js <script src="https://d3js.org/d3.v4.min.js"></script>
		github官方教程 <url:https://github.com/d3/d3/wiki/Tutorials>
		gallery 很多很酷的demo <url:https://github.com/d3/d3/wiki/Gallery>
		api参考 <url:https://github.com/d3/d3/blob/master/API.md>
		示例见: <url:./filets/d3_example> 
		d3-array 与lodash有些交集，但仍有一些独家工具（数学统计层面） <url:https://github.com/d3/d3-array>
			extent 求数组的范围，即[min, max]
			mean 求平均值（同lodash）
			median 中位数（lodash没有）
			quantile 数学含义未研究
			variance 方差
			deviation 偏差
			...
		d3-interpolate 插值算法（的构造器） <url:https://github.com/d3/d3-interpolate>
			为了标准化，插值的定义域都在0 ~ 1区间，但真正使用时可超过这个范围（越界）
				var i = d3.interpolateNumber(10, 20);
				i(0.0) => 10,  i(0.2) => 12, i(-1) => 0, i(2) => 30
			interpolateZoom 跟zoom相关的插值
				其数据的格式为[ 中心坐标cy, xy, 尺寸（一个值）w ]
		d3-scale 插值的进一步封装 <url:https://www.npmjs.com/package/d3-scale>
			其实是一个映射，将真实的数据，映射为用于可视化的值。比如将人口的比例映射为柱状图显示的长度
			import {scaleLinear} from 'd3-scale' // 注：不支持 import ds from 'd3-scale'，然后使用ds.scaleLinear的写法
			官方推荐作者写的介绍文章 <url:https://medium.com/@mbostock/introducing-d3-scale-61980c51545f>
			linear示例 <url:./filets/d3_example/1_bar_chart/main.js#d3-scale>
			附带几个常用的调色板 d3.schemeCategory10, d3.schemeCategory20, d3.schemeCategory20b, d3.schemeCategory20c
				其实就是几个预置的数组而已，和ordinal scale配合使用
			d3.scaleOrdinal() 构造一个离散的scale，定义域是整数序列
		d3-scale-chromatic 更全面的调色板<url:https://github.com/d3/d3-scale-chromatic>
		d3-hierarchy 层级结构（树形结构、树状） <url:https://github.com/d3/d3-hierarchy>
			d3.hierarchy(data[, children]) 传入一个数据源对象，返回一个解析过的层级对象
				children参数用来指定获取子节点的函数，缺省为 function children(d) { return d.children; }
				解析后的对象，拥有大量实用属性和方法（详见文档）
					之前的C++时代还尝试自己写过json_count之类的函数还很有成就感，现在直接被d3秒杀！
			d3.stratify 示例见 <url:./filets/d3_example/dendrogram/main.js#stratify>
			d3.cluster() 用于树形布局。（得到一个cluster对象，布局函数, 见下）
				cluster布局的特点是所有叶子节点都在最底层
				cluster(root) 传入一个层级数据结构，给其注入布局坐标
				示例 <url:./filets/d3_example/dendrogram/main.js>
			d3.tree() 与cluster的区别是tree更加紧凑，同一depth节点在同样的高度
			d3.pack() 用于圆球布局（circle packing） <url:./filets/d3_example/circle_packing/main.js#d3.pack>
				必须要使用node.sum方法
			node 是一个递归的结构
			node.descendants() 返回包括自己在内的所有子节点平铺的一个数组 <url:./filets/d3_example/dendrogram/main.js#descendants>
			node.sum(...) <url:./filets/d3_example/circle_packing/main.js#sum>
		d3-format 显示格式化 <url:https://github.com/d3/d3-format>
			详见文档，很强大的格式化工具库，比如 1234 格式化为 1,234
		d3-selection 跟jquery重叠相对最多的一块 
			selection.on('click', fn(d, i, ...){ this为当前dom元素 }) 事件响应
			selection.call 对selection调用一个函数，使用其call方法的意义在于实现链式调用
		d3-transition
			最简单示例： d3.select("body").transition().style("background-color", "lightblue")
			transition.duration(2000)
			transition.ease(timing_function) 指定时间函数
			transition.tween 自定义变换时间轴的行为
				区分于前面的类似于css transition的简便方法，tween可以通过流出时间插值，让用户根据时间插值来决定当前这一刻（这一帧）要处于什么状态
				这个思想和react motion非常接近
		d3-force <url:https://github.com/d3/d3-force>
		d3-drag <url:https://github.com/d3/d3-drag>
		d3-shape <url:https://github.com/d3/d3-shape>
		资源
			十二月咖啡 国内的不错的站点 <url:http://www.decembercafe.org/>
				做了很多酷炫的ui动画工具，其中有一个调色教程很赞
			ourd3js <url:http://www.ourd3js.com/>
			作者的代码博客
				Let’s Make a Bar Chart 柱状图1 <url:https://bost.ocks.org/mike/bar/>
				Let’s Make a Bar Chart, II：引入svg，以及ajax请求数据 <url:https://bost.ocks.org/mike/bar/2/>
				Let’s Make a Bar Chart, III: 引入坐标轴 <url:https://bost.ocks.org/mike/bar/3/>
				Three Little Circles <url:https://bost.ocks.org/mike/circles/>
				How Selections Work <url:https://bost.ocks.org/mike/selection/>
				How selectAll Works <url:https://bl.ocks.org/mbostock/5369146>
				Collapsible Tree 可折叠的树 <url:https://bl.ocks.org/mbostock/4339083>
				Tidy Tree（其实就是dendrogram） <url:https://bl.ocks.org/mbostock/4339184>
			Scott Murray: D3 Tutorials <url:http://alignedleft.com/tutorials/d3>
				About these tutorials <url:http://alignedleft.com/tutorials/d3/about>
				Fundamentals <url:http://alignedleft.com/tutorials/d3/fundamentals>
				Setup <url:http://alignedleft.com/tutorials/d3/setup>
				Adding elements <url:http://alignedleft.com/tutorials/d3/adding-elements>
				Chaining methods <url:http://alignedleft.com/tutorials/d3/chaining-methods>
			Adjustable Link Strength <url:https://bl.ocks.org/mbostock/aba1a8d1a484f5c5f294eebd353842da>
			Mike Bostock’s Blocks <url:https://bl.ocks.org/mbostock>
			Force Dragging I <url:https://bl.ocks.org/mbostock/2675ff61ea5e063ede2b5d63c08020c7>
			Force Dragging III <url:https://bl.ocks.org/mbostock/ad70335eeef6d167bc36fd3c04378048>
			Force-Directed Tree <url:https://bl.ocks.org/mbostock/95aa92e2f4e8345aaa55a4a94d41ce37>
	[AntV] 阿里的d3山寨版 <url:https://antv.alipay.com/zh-cn/index.html>
	ESLint <url:http://eslint.org/>
		参考 <url:http://eslint.org/docs/user-guide/getting-started>
			先全局安装，然后到具体项目目录eslint --init，会自动将eslint locally安装
			eslint --init的命令行向导界面做得很赞！（虽然生成的配置完全不能用）
			如果要在package.json里配置，加到eslintConfig字段
			真正使用时，使用局部安装到版本：node_modules\.bin\eslint .
		坑
			其默认的配置是完全不能用（连箭头函数都不能识别），但把create react app的配置（其实是在eslint-config-react-app模块里）拿来是可以直接用的
	表单
		form-urlencoded <url:https://www.npmjs.com/package/form-urlencoded> 
			官方querystring库的加强版，官方库不能处理多级对象，比如 {a:{b:1, c2}}，而这个库则可以
			目前在用，示例：
			var formurlencoded = require('form-urlencoded');
			var obj = {
				str : 'val',
				num : 0,
				arr : [3, {prop : false}, 1, null, 6],
				obj : {prop1 : null, prop2 : ['elem']}
			};
			console.log(formurlencoded(obj));
			// str=val&num=0&arr%5B%5D=3&arr%5B%5D%5Bprop%5D=false&arr% 
			// 5B%5D=1&arr%5B%5D=null&arr%5B%5D=6&obj%5Bprop1%5D=null&o 
			// bj%5Bprop2%5D%5B%5D=elem
	Immutable  <url:https://facebook.github.io/immutable-js>
		通用方法
			.toJS()
		需要用其自带的.equals或者Immutable.is函数来判断相等性
			例：
			const xx1 = IMap({ b : IMap({ 
				key : 1,
			}), a: 'fuck'})
			const xx2 = IMap({ a:'fuck', b: IMap({ 
				key : 1,
			}), })
			console.log(xx1.equals(xx2)) // true
			: 如果key下面的value是对象，要必须要将其immutable化
		github <url:https://github.com/facebook/immutable-js/>
		Map
			map1.set('b', 50);
			map1.get('b');
			例：这里不会进行深度immu化，m1下面的对象仍然保存原始的raw object形式
			Map({ 
			m1 : {
				type : 'mysql',
				x : 150,
				y : 100,
			})
		据说有一个devtool，在weavescope的源码里有看到，还未用过
			import installDevTools from 'immutable-devtools';
			installDevTools(Immutable);
	immutability-helper
	memoize-one 只记忆上一次调用 <url:https://www.npmjs.com/package/memoize-one>
		lodash的memoize有点复杂，很多时候这个库更实用
	Freezer.js: 另一个immutable的方案 <url:https://github.com/arqex/freezer>
		最大优势：很方便地更新一个很深的节点数据
		比immutable.js更轻量 与React结合时，相当于取代react的state，setState的机制
			它本身有store的概念，似乎有一定的和redux结合的可能性，但有一些文档则是建议用freezer代替flux(or redux)？有待好好研究 <url:https://medium.com/@arqex/react-the-simple-way-cabdf1f42f12#.g41jpw16v>
		世界观：store和state（data），store（全局唯一，存放data），data从store获取, immutable
			store = new Freezer({..初始状态..}) // 构造函数的参数一定是个对象（至少是{}），缺省参数的话会报错
			state = store.get() // 获得data
			state.set(key, value)或者state.set({...}) // 后者类似react setState
				该调用改变了store里的数据，返回新的修改后期望得到的变量对象，但原状态的引用者（这里是state），仍然保持不变（immutable）
				state.reset({...}) 类似react replaceState
				对象删除属性：obj.remove('a'), obj.remove(['a', 'b'])
				「注」不支持递归深度set
			store.on('update', function( currentState, prevState ){ }) // 监听state变化，作为取代react setState机制的必要条件之一
			store.set(another_state) // 重置data，注意与data.set相区别
			state.pivot() 对于需要一次性更新多处地方的场景，非常有用，例
				store.get().people.pivot().John.set({age: 30}).Alice.set({age: 30})
				注：在下一个tick时，pivot会被自动清除，使其不影响后面的使用
					即，上例中如果把两个set操作直接断开来执行的话，是不能正常工作的
			state.remove 删除属性
				freezer.get().remove('d').remove(['b', 'c'])
		坑
			与某些库结合使用时，需要净化数据（使用toJS()方法，或者是用modash里的wash）。比如_.merge，如果不wash将得不到正确的结果
	时间操作
		moment 较受欢迎 <url:http://momentjs.com/docs/#/displaying/format/>
			import moment from 'moment'
			const tag = moment().format('YYYYMMDD_HH.mm') // 坑：注意是moment()，而不是直接用moment!
		date-fns 后起之秀。dan大神推荐过 <url:https://date-fns.org/>
			import { format } from 'date-fns'
			format(new Date(), 'yyyy-MM-dd', )
	jsmind 思维导图js库
	cookie操作 js-cookie <url:https://www.npmjs.com/package/js-cookie>
	颜色操作 color <url:https://www.npmjs.com/package/color>
		功能非常全面，可以对颜色进行各种变换，运算，比如求亮度，求灰度，颜色混合等
	url解析
		query-string <url:https://www.npmjs.com/package/query-string> <url:https://github.com/sindresorhus/query-string>
			暂时用的是这个，github star较高
		querystring: 这是将node内建的querystring模块可移植化. 似乎更应该被使用？<url:https://github.com/Gozala/querystring>
	yaml
		js-yaml: 目前正使用 <url:https://www.npmjs.com/package/js-yaml>
			坑！：我已经修改了其代码！见自己folk的github地址，使用该库时要注意！
			从npm文档上看，是针对nodejs的，但目前前端也正在使用未发现问题
			以抛异常的方式处理错误
			yaml.dump(obj[, opts]) // 从对象导出yaml
			yaml.load(str[, opts])
		yamljs <url:https://www.npmjs.com/package/yamljs> <url:https://github.com/jeremyfa/yaml.js>
			使用dump的时候，好像有bug 2016年12月23日
		yaml <url:https://www.npmjs.com/package/yaml>
	jszip 前后端通用的压缩库（打zip包和解zip包） <url:https://stuk.github.io/jszip/>
		支持直接从前端下载
	dom-align <url:https://github.com/yiminghe/dom-align>
		rc-align以及ant design里tooltip组件的基石. 实现类似Sticker的功能
	layui（前身为layer） <url:http://www.layui.com/>
	uuid <url:https://www.npmjs.com/package/uuid>
		import uuid from 'uuid/v1' // 还有v4, v5，一般用v1即可
		直接 uuid() 即可生成
	ART 绘图 <url:https://github.com/sebmarkbage/art/>
	Vue.js <url:http://cn.vuejs.org/>
		60分钟快速入门 <url:http://www.cnblogs.com/rik28/p/6024425.html>
	直接操作dom样式：dom-css <url:https://www.npmjs.com/package/dom-css>
	图形库
		强大的图形库：gojs!! <url:http://gojs.net/latest/samples/dynamicPorts.html>
			太厉害了！感觉比d3还要厉害啊
			使用canvas来实现
			虽然好像不是开源，但好像给出了model!!!，是一个很好的参考
		JSNetworkX （astexplorer的作者从python库NetworkX上移植过来的） <url:https://github.com/fkling/JSNetworkX>
		gooflow流程设计插件, 好像也很有参考价值 <url:http://www.jq22.com/jquery-info16922>
	[theia] <url:https://github.com/theia-ide/theia>
	xterm.js web终端的解决方案 <url:https://github.com/sourcelair/xterm.js>
		vs code也使用了该库
	ascii表格
		string-length: 除了正确计算unicode长度之外，还忽略掉了ansi控制代码 <url:https://www.npmjs.com/package/string-length>
		string-width: 计算显示的长度，比如中文占2的长度，同样忽略掉ansi控制代码<url:https://github.com/sindresorhus/string-width>
		widest-line: 计算一个多行字符串里面最宽的一行的显示长度 <url:https://github.com/sindresorhus/widest-line>
			感觉不是很实用
	css-element-queries <url:https://www.npmjs.com/package/css-element-queries>
		里面有一个ResizeSensor，可以用来监听dom元素尺寸的变化
		但其有一定的侵入作用: 会将原来元素的position改为relative，并且还会注入一些辅助的元素
		因此对于在svg foreignObject里的html元素来说，可能会带来问题
	3D库 Three.js <url:https://threejs.org/>
		一些很酷炫的demo <url:http://christmasexperiments.com/experiments>
		react-three-render demo <url:http://toxicfork.github.io/react-three-renderer-example/#/webgl_draggable_cubes>
		react-three <url:https://github.com/Izzimach/react-three>
		The interactive example from react-three <url:http://izzimach.github.io/demos/react-three-interactive/index.html>
		react and three.js <url:https://tweedegolf.com/2016/02/16/react-threejs/>
	html编码、解码
		He（html entities） <url:https://www.npmjs.com/package/he>
			issue: encode一段中文会把所有东西都encode进去了
	模板 ejs <url:https://www.npmjs.com/package/ejs>
		流程<% %>
		转义<%= %>
		不转义<%- %>
		找到几个vim的插件，未体验 <url:https://github.com/nikvdp/ejs-syntax> <url:https://github.com/briancollins/vim-jst>
